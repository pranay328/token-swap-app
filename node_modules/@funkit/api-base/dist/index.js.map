{
  "version": 3,
  "sources": ["../src/consts/api.ts", "../src/utils/error.ts", "../src/consts/retry.ts", "../src/consts/customers.ts", "../src/utils/checkout.ts", "../src/utils/request.ts", "../src/services/assets/endpoints.ts", "../src/services/bridge/endpoints.ts", "../src/services/bridge/types.ts", "../src/services/checkout/endpoints.ts", "../src/services/checkout/types.ts", "../src/services/direct-execution/endpoints.ts", "../src/services/direct-execution/types.ts", "../src/services/faucet/endpoints.ts", "../src/services/fw-access/endpoints.ts", "../src/services/fw-group/endpoints.ts", "../src/services/fw-info/endpoints.ts", "../src/services/fw-operation/endpoints.ts", "../src/services/fw-operation/types.ts", "../src/services/fw-paymaster/endpoints.ts", "../src/services/fw-paymaster/types.ts", "../src/services/fw-user/endpoints.ts", "../src/services/meld/endpoints.ts", "../src/services/meld/types.ts", "../src/services/mesh/endpoints.ts", "../src/services/mesh/types.ts", "../src/services/moonpay/endpoints.ts", "../src/services/organization/endpoints.ts", "../src/services/stripe/endpoints.ts", "../src/services/support/endpoints.ts"],
  "sourcesContent": ["export const API_BASE_URL = process.env.API_BASE_URL || 'https://api.fun.xyz/v1' // Production\n\n// TODO: change it to fun.xyz domain\nexport const MESH_API_BASE_URL = 'https://frog.fun.xyz'\n// export const MESH_API_BASE_URL = 'http://localhost:3001'\n\nexport const FUN_FAUCET_URL = 'https://api.fun.xyz/demo-faucet'\n", "import {\n  InvalidParameterError,\n  ResourceNotFoundError,\n  UserOpFailureError,\n} from '@funkit/utils'\nimport type { AttemptContext } from '@lifeomic/attempt'\n\nexport const errorAbortHandler = (err: Error, context: AttemptContext) => {\n  if (\n    err instanceof ResourceNotFoundError ||\n    err instanceof InvalidParameterError ||\n    err instanceof UserOpFailureError\n  ) {\n    context.abort()\n  }\n}\n", "import type { PartialAttemptOptions } from '@lifeomic/attempt'\n\nimport { errorAbortHandler } from '../utils/error'\n\nexport type BaseResponse = unknown\n\nexport type RetryOptions<T = BaseResponse> = PartialAttemptOptions<T>\n\nexport const DEFAULT_RETRY_OPTIONS = {\n  delay: 100,\n  initialDelay: 0,\n  maxDelay: 3000,\n  factor: 2,\n  maxAttempts: 5,\n  timeout: 0,\n  jitter: true,\n  minDelay: 0,\n  handleError: errorAbortHandler,\n  handleTimeout: null,\n  beforeAttempt: null,\n  calculateDelay: null,\n} as RetryOptions\n", "export const DEGEN_API_KEY = 'm4iHIILHcL4gN8EXCMzGe8zIdhuCXxck49mWajzJ'\nexport const DYDX_API_KEY = 'NJq0CGrsE19xBbP1vHyBOp8xJvzYo9kayJHqDFP5'\nexport const POLYMARKET_API_KEY = 'Y53dikxXdT4E3afI1l8BMBSWgyhKvf65k6Dut1k6'\nexport const OSTIUM_API_KEY = 'SMbBD7DS9b3EPcyBVg4a8az1rRWR9xB068chHoUN'\nexport const DEV_API_KEY = 'Z9SZaOwpmE40KX61mUKWm5hrpGh7WHVkaTvQJpQk'\nexport const BANKR_API_KEY = 'vWe20Dfyui2ouvfOhtSTY3Czeo8lFdbo5xXQBALZ'\nexport const QUICKSWAP_API_KEY = 'sdbYyJRkXz7uuCCiA7KDu2SzYknwgwCN5rgBllKR'\nexport const BSX_API_KEY = 'zN1zrkmLQn4oZtLUW9Qt02uuBI3Jvrgj8Ni40Gf1'\nexport const BENQI_API_KEY = 'q8qZWLvviLaOaG4bX3w2v6zLN9uxNPaU6CX8I0Gd'\nexport const ETHEREAL_API_KEY = 'M3uox3cw0u8YCPV9cIREA6AugUMvPFTk6qOpm4um'\nexport const KATANA_API_KEY = 'OXLUmejkh9PlNDS4gSvi9gcEWacOpTz2KUVepVf4'\nexport const ETHERFI_API_KEY = 'GyJMyQ3juDarKooebGRu16Ncogwhm59h2DIjCu1p'\nexport const SUSHI_API_KEY = 'HKHvPSPDezaxsTohFgDuG4WpKW6hB4SFYyztm9vc'\n//TODO: add real key\nexport const FELIX_API_KEY = 'Z9SZaOwpmE40KX61mUKWm5hrpGh7WHVkaTvQJpQk'\n", "import { toHex } from 'viem'\n\nexport function randomBytes(length: number) {\n  const bytes = new Uint8Array(length)\n  for (let i = 0; i < length; i++) {\n    bytes[i] = Math.floor(Math.random() * 256)\n  }\n  return toHex(bytes)\n}\n\nexport function generateRandomCheckoutSalt() {\n  return toHex(BigInt(randomBytes(32)))\n}\n\nexport function roundToNearestBottomTenth(n: number) {\n  return Math.floor(n / 10) * 10\n}\n", "import { retry } from '@lifeomic/attempt'\n\nimport type { BaseRequest } from '../consts/request'\nimport {\n  type BaseResponse,\n  DEFAULT_RETRY_OPTIONS,\n  type RetryOptions,\n} from '../consts/retry'\n\nimport {\n  AccessDeniedError,\n  ErrorCode,\n  InternalFailureError,\n  InvalidParameterError,\n  ResourceNotFoundError,\n  ThrottlingError,\n  UserOpFailureError,\n  jsonStringifyWithBigIntSanitization,\n} from '@funkit/utils'\nimport type {\n  DeleteRequest,\n  GetRequest,\n  PostRequest,\n  PutRequest,\n} from './../consts/request'\n\ntype RequestError = {\n  errorMsg: string\n  errorCode: string\n}\n\nexport async function sendRequest<T = BaseResponse>({\n  uri,\n  method,\n  apiKey,\n  body = {},\n  logger,\n  retryOptions = {},\n  signal,\n}: BaseRequest): Promise<T> {\n  const headers = {\n    'Content-Type': 'application/json',\n    ...(apiKey ? { 'X-Api-Key': apiKey } : {}),\n  }\n\n  try {\n    const finalRetryOptions = {\n      ...DEFAULT_RETRY_OPTIONS,\n      ...retryOptions,\n    } as RetryOptions<T>\n\n    return retry<T>(async (context) => {\n      const startTimeMs = Date.now()\n      const fetchParams = {\n        method,\n        headers,\n        redirect: 'follow',\n        signal,\n        body:\n          method !== 'GET'\n            ? jsonStringifyWithBigIntSanitization(body)\n            : undefined,\n      } as RequestInit\n\n      logger?.info('api-base:sendRequest_before', {\n        uri,\n        fetchParams,\n        startTimeMs,\n      })\n      const response = await fetch(uri, fetchParams)\n      const json = await response.json()\n      const endTimeMs = Date.now()\n      logger?.info('api-base:sendRequest_after', {\n        url: uri,\n        fetchParams,\n        endTimeMs,\n        response: {\n          body: json,\n          status: response.status,\n        },\n        durationMs: endTimeMs - startTimeMs,\n        retries: context.attemptNum,\n      })\n\n      if (response.ok) {\n        return json\n      }\n\n      const { errorMsg, errorCode } = json as RequestError\n\n      if (response.status === 400) {\n        throw new InvalidParameterError(\n          ErrorCode.InvalidParameter,\n          `bad request ${JSON.stringify(json)}`,\n          errorMsg,\n          { body },\n          'check the api call parameters. its mostly because some call parameters are wrong',\n          'https://docs.fun.xyz',\n        )\n      }\n      if (response.status === 403) {\n        throw new AccessDeniedError(\n          ErrorCode.Unauthorized,\n          'Invalid API key or insufficient access.',\n          errorMsg,\n          { apiKey },\n          'Check your api key at https://app.fun.xyz and check with fun team if you believe something is off',\n          'https://docs.fun.xyz',\n        )\n      }\n      if (response.status === 404) {\n        throw new ResourceNotFoundError(\n          ErrorCode.ServerMissingData,\n          JSON.stringify(json),\n          errorMsg,\n          { body },\n          'check the api call parameters. its mostly because some call parameters are wrong',\n          'https://docs.fun.xyz',\n        )\n      }\n      if (response.status === 429) {\n        throw new ThrottlingError(\n          ErrorCode.RequestLimitExceeded,\n          `too many requests ${JSON.stringify(json)}`,\n          'Too many requests',\n          { body },\n          'you are making too many requests. please slow down. Reach out to fun team if you need more quota',\n          'https://docs.fun.xyz',\n        )\n      }\n      if (response.status === 500) {\n        if (errorCode === ErrorCode.UserOpFailureError) {\n          throw new UserOpFailureError(\n            ErrorCode.UserOpFailureError,\n            JSON.stringify(json), // UserOpFailureError may JSON.parse this! Do not modify!\n            errorMsg,\n            { body },\n            'fix user op failure. Most of the time this is due to invalid parameters',\n            'https://docs.fun.xyz',\n          )\n        }\n        throw new InternalFailureError(\n          ErrorCode.ServerFailure,\n          `server failure ${JSON.stringify(json)}`,\n          errorMsg,\n          { body },\n          'retry later. if it still fails, please contact us.',\n          'https://docs.fun.xyz',\n        )\n      }\n      if (response.status === 504) {\n        throw new InternalFailureError(\n          ErrorCode.ServerTimeout,\n          `server timeout failure ${JSON.stringify(json)}`,\n          errorMsg,\n          { body },\n          'retry later. if it still fails, please contact us.',\n          'https://docs.fun.xyz',\n        )\n      }\n      if (!response.ok) {\n        throw new InternalFailureError(\n          ErrorCode.UnknownServerError,\n          `unknown server failure ${JSON.stringify(json)}`,\n          errorMsg,\n          { body },\n          'retry later. if it still fails, please contact us.',\n          'https://docs.fun.xyz',\n        )\n      }\n      return {}\n    }, finalRetryOptions)\n  } catch (err) {\n    logger?.error('api-base:fetch_error', {\n      url: uri,\n      method,\n      request: {\n        body,\n        headers,\n      },\n      error: err,\n    })\n\n    throw new InternalFailureError(\n      ErrorCode.ServerConnectionError,\n      `Cannot connect to Fun API Service ${err}`,\n      '',\n      { body },\n      'retry later. if it still fails, please contact us.',\n      'https://docs.fun.xyz',\n    )\n  }\n}\n\nexport async function sendGetRequest<T = BaseResponse>(\n  options: GetRequest,\n): Promise<T> {\n  return await sendRequest({ ...options, method: 'GET' })\n}\n\nexport async function sendPostRequest<T = BaseResponse>(\n  options: PostRequest,\n): Promise<T> {\n  return await sendRequest({ ...options, method: 'POST' })\n}\n\nexport async function sendPutRequest<T = BaseResponse>(\n  options: PutRequest,\n): Promise<T> {\n  return await sendRequest({ ...options, method: 'PUT' })\n}\n\nexport async function sendDeleteRequest(options: DeleteRequest): Promise<void> {\n  await sendRequest({ ...options, method: 'DELETE' })\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendGetRequest } from '../../utils'\nimport type {\n  Erc20AssetInfo,\n  GetAllWalletNFTsByChainIdRequest,\n  GetAllWalletNFTsByChainIdResponse,\n  GetAllWalletNFTsRequest,\n  GetAllWalletNFTsResponse,\n  GetAllWalletTokensByChainIdRequest,\n  GetAllWalletTokensByChainIdResponse,\n  GetAllWalletTokensRequest,\n  GetAllWalletTokensResponse,\n  GetAllowedAssetsRequest,\n  GetAllowedAssetsResponse,\n  GetAssetErc20ByChainAndSymbolRequest,\n  GetAssetPriceInfoRequest,\n  GetAssetPriceInfoResponse,\n  GetNftAddressRequest,\n  GetNftNameRequest,\n  GetWalletLidoWithdrawalsByChainId,\n  GetWalletLidoWithdrawalsByChainIdResponse,\n  NftAssetInfo,\n} from './types'\n\n/**\n * Gets the estimated dollar unit price of a tokenAddress for checkout\n * @param chainId https://chainlist.org/ e.g. \"1\" for ethereum\n * @param assetTokenAddress tokenAddress of the asset on the given chain\n * @param apiKey\n * @returns only `unitPrice` is relevant, since amount is not customizable (1 by default)\n */\nexport async function getAssetPriceInfo({\n  chainId,\n  assetTokenAddress,\n  ...options\n}: GetAssetPriceInfoRequest): Promise<GetAssetPriceInfoResponse> {\n  const priceInfo: GetAssetPriceInfoResponse = await sendGetRequest({\n    uri: `${API_BASE_URL}/asset/erc20/price/${chainId}/${assetTokenAddress}`,\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n  return priceInfo\n}\n\n/**\n * Gets the ERC20 asset info by chain and symbol\n * @param chainId https://chainlist.org/ e.g. \"1\" for ethereum\n * @param symbol symbol of the asset\n * @param apiKey\n */\nexport async function getAssetErc20ByChainAndSymbol({\n  chainId,\n  symbol,\n  ...options\n}: GetAssetErc20ByChainAndSymbolRequest): Promise<Erc20AssetInfo> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/asset/erc20/${chainId}/${symbol}`,\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n}\n\n/**\n * Get all tokens for a given wallet address\n * @param walletAddress\n * @param onlyVerifiedTokens If true, only return alchemy tokens that are verified(filters spam)\n * @param apiKey\n * @param signal AbortSignal to cancel the request when no longer needed\n */\nexport async function getAllWalletTokens({\n  walletAddress,\n  onlyVerifiedTokens,\n  ...options\n}: GetAllWalletTokensRequest): Promise<GetAllWalletTokensResponse> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/assets/erc20s/${walletAddress}?onlyVerifiedTokens=${onlyVerifiedTokens}`,\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n}\n\n/**\n * Get all tokens for a given wallet address on a specific chain\n * @param chainId https://chainlist.org/\n * @param walletAddress\n * @param onlyVerifiedTokens If true, only return alchemy tokens that are verified(filters spam)\n * @param apiKey\n */\nexport async function getAllWalletTokensByChainId({\n  chainId,\n  walletAddress,\n  onlyVerifiedTokens,\n  ...options\n}: GetAllWalletTokensByChainIdRequest): Promise<GetAllWalletTokensByChainIdResponse> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/assets/erc20s/${walletAddress}/${chainId}?onlyVerifiedTokens=${onlyVerifiedTokens}`,\n\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n}\n\n/**\n * Get list of assets that are allowed to be used for checkout\n * @param apiKey\n */\nexport async function getAllowedAssets(\n  options: GetAllowedAssetsRequest,\n): Promise<GetAllowedAssetsResponse> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/assets/allow`,\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n}\n\n/**=======================\n * POTENTIAL DEPRECATION\n *=======================*/\n\n/**\n * Get all the NFTs owned by a wallet\n * @param walletAddress\n * @param apiKey\n */\nexport async function getAllWalletNFTs({\n  walletAddress,\n  ...options\n}: GetAllWalletNFTsRequest): Promise<GetAllWalletNFTsResponse> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/assets/nfts/${walletAddress}`,\n    ...options,\n  })\n}\n\n/**\n * Get all the NFTs owned by a wallet on a specific chain\n * @param chainId From https://chainlist.org/\n * @param walletAddress Address of holder\n * @param apiKey\n */\nexport async function getAllWalletNFTsByChainId({\n  chainId,\n  walletAddress,\n  ...options\n}: GetAllWalletNFTsByChainIdRequest): Promise<GetAllWalletNFTsByChainIdResponse> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/assets/nfts/${walletAddress}/${chainId}`,\n    ...options,\n  })\n}\n\n/**\n * Get all lido withdrawal request ids for a wallet address on a specific chain\n * @param {string} chainId https://chainlist.org/ ie \"1\" for ethereum\n * @param {string} holderAddr Address of holder\n * @returns [readyToWithdrawRequestIds, notReadyToWithdrawRequestIds]\n */\nexport async function getWalletLidoWithdrawalsByChainId({\n  chainId,\n  walletAddress,\n  ...options\n}: GetWalletLidoWithdrawalsByChainId): Promise<GetWalletLidoWithdrawalsByChainIdResponse> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/assets/lido-withdrawals/${walletAddress}/${chainId}`,\n    ...options,\n  })\n}\n\n/**\n * Get the name of an NFT collection\n * @param {string} chainId https://chainlist.org/\n * @param {string} nftAddress Address of NFT\n */\nexport async function getNftName({\n  chainId,\n  nftAddress,\n  ...options\n}: GetNftNameRequest): Promise<NftAssetInfo> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/asset/nft/${chainId}/${nftAddress}`,\n    ...options,\n  })\n}\n\n/**\n * Get the address and chainId of an NFT collection\n * @param {string} name Name of NFT\n */\nexport async function getNftAddress({\n  name,\n  ...options\n}: GetNftAddressRequest): Promise<NftAssetInfo> {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/asset/nft?name=${name}`,\n    ...options,\n  })\n}\n", "import { MESH_API_BASE_URL } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  CreateBridgeBankAccountRequest,\n  CreateBridgeBankAccountResponse,\n  CreateFrogAndBridgeAccountRequest,\n  CreateFrogAndBridgeAccountResponse,\n  FindBridgeKycLinkRequest,\n  FindBridgeKycLinkResponse,\n  GetBridgeBankAccountRequest,\n  GetBridgeBankAccountResponse,\n  GetBridgeCustomerRequest,\n  GetBridgeCustomerResponse,\n  GetOrCreateFrogAccountRequest,\n  GetOrCreateFrogAccountResponse,\n} from './types'\n\nexport async function getFrogAccount({\n  subAccountId,\n  subAccountType,\n  ...options\n}: GetOrCreateFrogAccountRequest): Promise<GetOrCreateFrogAccountResponse> {\n  const search = new URLSearchParams({\n    subAccountId,\n    subAccountType,\n  })\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/account?${search}`,\n    ...options,\n  })\n}\n\nexport async function createFrogAccount({\n  subAccountId,\n  subAccountType,\n  ...options\n}: GetOrCreateFrogAccountRequest): Promise<GetOrCreateFrogAccountResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/api/account`,\n    body: {\n      subAccountId,\n      subAccountType,\n    },\n    ...options,\n  })\n}\n\nexport async function getBridgeCustomer({\n  guid,\n  ...options\n}: GetBridgeCustomerRequest): Promise<GetBridgeCustomerResponse> {\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/bridge?guid=${guid}`,\n    ...options,\n  })\n}\n\nexport async function createBridgeCustomer({\n  guid,\n  name,\n  email,\n  endorsement,\n  ...options\n}: CreateFrogAndBridgeAccountRequest): Promise<CreateFrogAndBridgeAccountResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/api/bridge`,\n    body: {\n      guid,\n      name,\n      email,\n      endorsement,\n    },\n    ...options,\n  })\n}\n\nexport async function getBridgeBankAccounts({\n  subAccountId,\n  ...options\n}: GetBridgeBankAccountRequest): Promise<GetBridgeBankAccountResponse> {\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/bridge/bank?subAccountId=${subAccountId}`,\n    ...options,\n  })\n}\n\nexport async function createBridgeBankAccount({\n  tokenName,\n  chainName,\n  destinationAddress,\n  subAccountId,\n  sourceCurrency,\n  ...options\n}: CreateBridgeBankAccountRequest): Promise<CreateBridgeBankAccountResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/api/bridge/bank`,\n    body: {\n      subAccountId,\n      tokenName,\n      chainName,\n      destinationAddress,\n      sourceCurrency,\n    },\n    ...options,\n  })\n}\n\nexport function getBridgeKycLink({\n  guid,\n  ...options\n}: FindBridgeKycLinkRequest): Promise<FindBridgeKycLinkResponse> {\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/bridge/kyclink?guid=${guid}`,\n    ...options,\n  })\n}\n", "import type { Address } from 'viem'\nimport type { BaseApiRequest } from '../../consts'\n\ndeclare const brand: unique symbol\n\nexport type BridgeCustomerId = string & { [brand]: 'BridgeCustomerId' }\nexport type Guid = string & { [brand]: 'Guid' }\n\ntype DateString = `${number}-${number}-${number}T${number}:${number}:${number}Z`\n\nexport enum BridgeCustomerStatus {\n  ACTIVE = 'active',\n  AWAITING_QUESTIONNAIRE = 'awaiting_questionnaire',\n  /** Ultimate Beneficial Owner - only relevant for business customers https://apidocs.bridge.xyz/docs/business-ownership-documents */\n  AWAITING_UBO = 'awaiting_ubo',\n  INCOMPLETE = 'incomplete',\n  NOT_STARTED = 'not_started',\n  OFFBOARDED = 'offboarded',\n  PAUSED = 'paused',\n  REJECTED = 'rejected',\n  UNDER_REVIEW = 'under_review',\n}\n\n// https://apidocs.bridge.xyz/docs/rejection-reasons\nexport interface RejectionReason {\n  created_at: DateString\n  developer_reason: string\n  reason: string\n}\n\nexport interface BridgeCustomer {\n  id: BridgeCustomerId\n  first_name: string\n  last_name: string\n  rejection_reasons: RejectionReason[]\n  status: BridgeCustomerStatus\n}\n\nexport enum BridgeKycStatus {\n  APPROVED = 'approved',\n  INCOMPLETE = 'incomplete',\n  NOT_STARTED = 'not_started',\n  REJECTED = 'rejected',\n  UNDER_REVIEW = 'under_review',\n}\n\nexport enum BridgeTosStatus {\n  APPROVED = 'approved',\n  PENDING = 'pending',\n}\n\nexport enum BridgeCustomerType {\n  BUSINESS = 'business',\n  INDIVIDUAL = 'individual',\n}\n\nexport interface BridgeKYCLinks {\n  id: string\n  customer_id: BridgeCustomerId\n  created_at: DateString\n  email: string\n  kyc_link: string\n  kyc_status: BridgeKycStatus\n  tos_link: string\n  tos_status: BridgeTosStatus\n  type: BridgeCustomerType\n}\n\nexport interface SubAccountBase {\n  id: number\n  createdAt: DateString\n  updatedAt: DateString\n  guid: Guid\n  subAccountType: string\n  subAccountId: string\n  isDeleted: boolean\n}\n\nexport interface WalletSubAccount extends SubAccountBase {\n  subAccountType: 'wallet'\n  subAccountId: Address\n}\n\nexport interface BridgeSubAccount extends SubAccountBase {\n  subAccountType: 'bridge'\n  subAccountId: BridgeCustomerId\n}\n\nexport type SubAccount = WalletSubAccount | BridgeSubAccount\n\nexport interface GetOrCreateFrogAccountRequest extends BaseApiRequest {\n  subAccountType: 'wallet'\n  subAccountId: Address\n}\n\nexport interface GetOrCreateFrogAccountResponse {\n  accounts: SubAccount[]\n}\n\nexport interface GetBridgeCustomerRequest extends BaseApiRequest {\n  guid: Guid\n}\n\nexport interface GetBridgeCustomerResponse {\n  account: SubAccount\n  bridgeCustomer: BridgeCustomer\n}\n\nexport enum BridgeEndorsement {\n  BASE = 'base',\n  SEPA = 'sepa',\n}\n\nexport type BridgeAccount = {\n  guid: Guid\n  name: string\n  email: string\n  endorsement: BridgeEndorsement\n}\nexport type CreateFrogAndBridgeAccountRequest = BaseApiRequest & BridgeAccount\n\nexport type CreateFrogAndBridgeAccountResponse =\n  | {\n      newCreated: true\n      /** kyc link info will be present only when create new customer */\n      kycLinks: BridgeKYCLinks\n    }\n  | {\n      newCreated: false\n      kycLink: string\n    }\n\nexport type BridgeVirtualAcountId = string & {\n  [brand]: 'BridgeVirtualAcountId'\n}\n\nexport interface BridgeDestination {\n  address: `0x${string}`\n  currency: 'usdc' | 'usdt' | 'usdb' | 'dai'\n  payment_rail: 'ethereum' | 'arbitrum' | 'base' | 'polygon' | 'solana'\n}\n\nexport enum BridgeVirtualBankAccountStatus {\n  ACTIVATED = 'activated',\n  DEACTIVATED = 'deactivated',\n}\n\nexport interface BridgeVirtualBankAccount {\n  id: BridgeVirtualAcountId\n  destination: BridgeDestination\n  developer_fee_percent: `${number}`\n  source_deposit_instructions: {\n    payment_rails: string[]\n    currency: string\n    bank_name: string\n    bank_address: string\n    bank_beneficiary_name?: string\n    bank_beneficiary_address?: string\n    // only us bank accounts have routing and account numbers\n    bank_routing_number?: string\n    bank_account_number?: string\n    // https://wise.com/us/iban/ IBAN stands for International Bank Account Number.\n    // It\u2019s an internationally-agreed code made up of up to 34 letters and numbers\n    // that helps banks to process transfers around the world.\n    account_holder_name?: string\n    iban?: string\n    bic?: string\n  }\n  status: BridgeVirtualBankAccountStatus\n}\n\nexport interface GetBridgeBankAccountRequest extends BaseApiRequest {\n  subAccountId: BridgeCustomerId\n}\n\nexport interface GetBridgeBankAccountResponse {\n  bankAccounts: BridgeVirtualBankAccount[]\n}\n\nexport interface CreateBridgeBankAccountRequest extends BaseApiRequest {\n  subAccountId: BridgeCustomerId\n  sourceCurrency: 'usd' | 'eur'\n  tokenName: 'usdb' | 'usdc' | 'usdt' | 'dai'\n  chainName: 'arbitrum' | 'base' | 'ethereum' | 'polygon' | 'solana'\n  destinationAddress: Address\n}\n\nexport interface CreateBridgeBankAccountResponse {\n  bankAccount: BridgeVirtualBankAccount\n}\n\nexport interface FindBridgeKycLinkRequest extends BaseApiRequest {\n  guid: Guid\n}\n\nexport interface FindBridgeKycLinkResponse {\n  kycLink: string\n}\n", "import Big from 'big.js'\nimport type { Address } from 'viem'\n\nimport { ErrorCode, ResourceNotFoundError } from '@funkit/utils'\nimport type {\n  CheckoutApiQuoteResponse,\n  CheckoutQuoteResponse,\n} from '@funkit/utils'\nimport { API_BASE_URL, type BaseApiRequest } from '../../consts'\nimport {\n  generateRandomCheckoutSalt,\n  roundToNearestBottomTenth,\n  sendGetRequest,\n  sendPostRequest,\n} from '../../utils'\nimport {\n  type CheckoutApiInitParams,\n  type CheckoutApiQuoteParams,\n  type CheckoutDeactivateParams,\n  type CheckoutHistoryItem,\n  type CheckoutInitParams,\n  type CheckoutInitResponse,\n  type CheckoutInitTokenTransferAddressParams,\n  type CheckoutInitTokenTransferResponse,\n  type CheckoutQuoteParams,\n  CheckoutState,\n  type CheckoutTransferSponsorshipApiParams,\n  type CheckoutTransferSponsorshipParams,\n  type CheckoutTransferSponsorshipResponse,\n  type RiskAssessmentParams,\n  type RiskAssessmentResponse,\n} from './types'\n\nconst DEFAULT_EXPIRATION_TIMESTAMP_MS = 15 * 60 * 1000 // 15 minutes\n\n/**\n * Gets a checkout quote (estimation).\n * @param fromChainId The ID of the chain where funds will be provided from.\n * @param fromTokenAddress The asset to fund the checkout. This must be either a chain native token or an ERC-20, on the fromChainId.\n * @param fromTokenDecimals The number of decimals for the fromTokenAddress.\n * @param toChainId The ID of the chain where the checkout operation is to be performed.\n * @param toTokenAddress The wanted asset for the checkout operation. This must be either a chain native token or an ERC-20, on the target chain.\n * @param toTokenAmount The amount of wanted asset for the checkout operation in base units.\n * @param toTokenDecimals The number of decimals for the toTokenAddress.\n * @param apiKey A valid fun api key.\n * @param signal AbortSignal to cancel the request when no longer needed\n * @return {Promise<CheckoutCoreQuoteResponse>} The formatted quote object\n */\nexport async function getCheckoutQuote({\n  fromChainId,\n  fromTokenAddress,\n  fromTokenDecimals,\n  toChainId,\n  toTokenAddress,\n  toTokenDecimals,\n  toTokenAmount,\n  sponsorInitialTransferGasLimit,\n  recipientAddr,\n  userId,\n  ...options\n}: CheckoutQuoteParams): Promise<CheckoutQuoteResponse> {\n  try {\n    const toMultipler = 10 ** toTokenDecimals\n    const toAmountBaseUnitBI = BigInt(Math.floor(toTokenAmount * toMultipler))\n    const queryParams: CheckoutApiQuoteParams = {\n      userId,\n      fromChainId,\n      fromTokenAddress,\n      toChainId,\n      toTokenAddress,\n      toAmountBaseUnit: toAmountBaseUnitBI.toString(),\n      // Only pass in recipientAddr if specified\n      ...(recipientAddr ? { recipientAddr } : {}),\n      // Rounding nearest tenth second (instead of seconds) to better support backend quote caching feature\n      // Reference: https://vintage-heaven-3cd.notion.site/API-Gateway-Caching-and-Pre-Warming-System-Draft-ee7909d9b85f43c793ce7bd2607bec02?pvs=4\n      // Note: Rounding *down* instead of a regular round to safeguard against edge case of timing passing frontend range validation but failing backend range validation\n      checkoutExpirationTimestampSeconds: roundToNearestBottomTenth(\n        Math.round((Date.now() + DEFAULT_EXPIRATION_TIMESTAMP_MS) / 1000),\n      ).toString(),\n      sponsorInitialTransferGasLimit,\n    }\n\n    const searchParams = new URLSearchParams(queryParams)\n    const quoteRes = (await sendGetRequest({\n      uri: `${API_BASE_URL}/checkout/quote?${searchParams}`,\n      ...options,\n    })) as CheckoutApiQuoteResponse\n\n    const fromMultipler = 10 ** fromTokenDecimals\n    // Format the response for frontend usage\n    return {\n      quoteId: quoteRes.quoteId,\n      fromTokenAddress: quoteRes.fromTokenAddress,\n      estFeesUsd: quoteRes.estFeesUsd,\n      estSubtotalUsd: quoteRes.estSubtotalUsd,\n      estTotalUsd: quoteRes.estTotalUsd,\n      estCheckoutTimeMs: quoteRes.estCheckoutTimeMs,\n      estTotalFromAmountBaseUnit: quoteRes.estTotalFromAmountBaseUnit,\n      estSubtotalFromAmountBaseUnit: quoteRes.estSubtotalFromAmountBaseUnit,\n      estFeesFromAmountBaseUnit: quoteRes.estFeesFromAmountBaseUnit,\n      estMarketMakerGasUsd: quoteRes.estMarketMakerGasUsd,\n      lpFeePercentage: quoteRes.lpFeePercentage,\n      lpFeeUsd: quoteRes.lpFeeUsd,\n      // Added fields\n      estFeesFromAmount: new Big(quoteRes.estFeesFromAmountBaseUnit)\n        .div(fromMultipler)\n        .toString(),\n      estSubtotalFromAmount: new Big(quoteRes.estSubtotalFromAmountBaseUnit)\n        .div(fromMultipler)\n        .toString(),\n      estTotalFromAmount: new Big(quoteRes.estTotalFromAmountBaseUnit)\n        .div(fromMultipler)\n        .toString(),\n    }\n  } catch (err: unknown) {\n    throw new Error(\n      `An error occurred trying to generate a checkout quote: ${\n        err instanceof Error ? err.message : JSON.stringify(err)\n      }`,\n    )\n  }\n}\n\n/**\n * Initializes a checkout\n * @param userOp The checkout UserOp, signed.\n * @param quoteId The quoteId specific to the checkout.\n * @param apiKey A valid fun api key.\n * @return {Address} The generated deposit address\n */\nexport async function initializeCheckout({\n  userOp,\n  quoteId,\n  sourceOfFund,\n  clientMetadata,\n  ...options\n}: CheckoutInitParams): Promise<CheckoutInitResponse> {\n  const body = {\n    ...(userOp ? { userOp } : {}),\n    quoteId,\n    sourceOfFund,\n    salt: generateRandomCheckoutSalt(),\n    clientMetadata,\n  } as CheckoutApiInitParams\n  const res: { depositAddr?: Address } = await sendPostRequest({\n    uri: `${API_BASE_URL}/checkout`,\n    body,\n    ...options,\n  })\n  if (!res?.depositAddr) {\n    throw new ResourceNotFoundError(\n      ErrorCode.CheckoutInitDepositAddrNotFound,\n      'Unable to initialize checkout',\n      'Unable to initialize checkout',\n      body,\n      '',\n      'https://docs.fun.xyz',\n    )\n  }\n  return { depositAddr: res.depositAddr }\n}\n\nexport async function deactivateCheckout({\n  depositAddress,\n  ...options\n}: CheckoutDeactivateParams) {\n  try {\n    await sendPostRequest({\n      uri: `${API_BASE_URL}/checkout/update/${depositAddress}`,\n      body: {\n        // Fixed state to cancel the checkout\n        state: CheckoutState.CANCELLED,\n      },\n      ...options,\n    })\n    return true\n  } catch (_err) {\n    throw new Error('Unable to deactivate checkout')\n  }\n}\n\n/**\n * Gets a checkout given a depositAddress\n * @param depositAddress A unique deposit address associated with a backend checkout item.\n * @param apiKey A valid fun api key.\n * @param signal AbortSignal to cancel the request when no longer needed\n * @returns The checkout object if exists. Otherwise, null.\n */\nexport async function getCheckoutByDepositAddress({\n  depositAddress,\n  ...options\n}: BaseApiRequest & {\n  depositAddress: Address\n}): Promise<CheckoutHistoryItem | null> {\n  try {\n    return await sendGetRequest({\n      uri: `${API_BASE_URL}/checkout/${depositAddress}`,\n      ...options,\n    })\n  } catch (err) {\n    if (err instanceof ResourceNotFoundError) {\n      return null\n    }\n    throw err\n  }\n}\n\n/**\n * Gets all checkouts associated with a funWallet\n * @param funWalletAddress A funWallet address.\n * @param apiKey A valid fun api key.\n * @param signal AbortSignal to cancel the request when no longer needed\n * @returns A list of checkout objects if exists. Otherwise, an empty array.\n */\nexport async function getCheckoutsByFunWalletAddress({\n  funWalletAddress,\n  ...options\n}: BaseApiRequest & { funWalletAddress: Address }): Promise<\n  CheckoutHistoryItem[]\n> {\n  const res: CheckoutHistoryItem[] = await sendGetRequest({\n    uri: `${API_BASE_URL}/checkout/fun-wallet/${funWalletAddress}`,\n    ...options,\n  })\n  return res || []\n}\n\n/**\n * Gets all checkouts associated with a recipient address\n * @param recipientAddress A wallet address.\n * @param apiKey A valid fun api key.\n * @param signal AbortSignal to cancel the request when no longer needed\n * @returns A list of checkout objects if exists. Otherwise, an empty array.\n */\nexport async function getCheckoutsByRecipientAddress({\n  recipientAddress,\n  ...options\n}: BaseApiRequest & { recipientAddress: Address }): Promise<\n  CheckoutHistoryItem[]\n> {\n  const res = await sendGetRequest<CheckoutHistoryItem[] | null>({\n    uri: `${API_BASE_URL}/checkout/recipient/${recipientAddress}`,\n    ...options,\n  })\n  return res || []\n}\n\nexport interface GetCheckoutsByUserIdParams extends BaseApiRequest {\n  userId: string\n  limit?: number\n}\n\n/**\n * Gets all checkouts associated with a funkit userId string\n * @param userId A userId string.\n * @param apiKey A valid fun api key.\n * @param signal AbortSignal to cancel the request when no longer needed\n * @returns A list of checkout objects if exists. Otherwise, an empty array.\n */\nexport async function getCheckoutsByUserId({\n  userId,\n  limit,\n  ...options\n}: GetCheckoutsByUserIdParams): Promise<CheckoutHistoryItem[]> {\n  const query = limit\n    ? new URLSearchParams({\n        limit: limit.toString(),\n      })\n    : ''\n  const res = await sendGetRequest<CheckoutHistoryItem[] | null>({\n    uri: `${API_BASE_URL}/checkout/userId/${userId}?${query}`,\n    ...options,\n  })\n  return res || []\n}\n\nexport async function getPaymasterDataForCheckoutSponsoredTransfer({\n  depositAddress,\n  transferUserOp,\n  ...options\n}: CheckoutTransferSponsorshipParams): Promise<CheckoutTransferSponsorshipResponse> {\n  const body = {\n    depositAddress,\n    userOp: transferUserOp,\n  } as CheckoutTransferSponsorshipApiParams\n  const res = await sendPostRequest({\n    uri: `${API_BASE_URL}/checkout/sponsor-transfer`,\n    body,\n    ...options,\n  })\n  if (!res) {\n    // TODO: Better error handling\n    throw new Error('Unable to get sponsorship information')\n  }\n  return res as CheckoutTransferSponsorshipResponse\n}\n\nexport async function getRiskAssessmentForAddress({\n  address,\n  ...options\n}: RiskAssessmentParams) {\n  const response = (await sendGetRequest({\n    uri: `${API_BASE_URL}/checkout/risk-assessment?address=${address}`,\n    ...options,\n    // Protect us against chainalysis ratelimiting\n    retryOptions: { maxAttempts: 2 },\n  })) as RiskAssessmentResponse\n\n  return response\n}\n\nexport async function initializeCheckoutTokenTransferAddress({\n  apiKey,\n  logger,\n  signal,\n  ...body\n}: CheckoutInitTokenTransferAddressParams): Promise<CheckoutInitTokenTransferResponse> {\n  const res = await sendPostRequest<CheckoutInitTokenTransferResponse | null>({\n    uri: `${API_BASE_URL}/eoa`,\n    body,\n    apiKey,\n    logger,\n    signal,\n  })\n  if (!res?.depositAddr) {\n    throw new ResourceNotFoundError(\n      ErrorCode.CheckoutInitDepositAddrNotFound,\n      'Unable to initialize checkout token transfer address',\n      'Unable to initialize checkout token transfer address',\n      body,\n      '',\n      'https://docs.fun.xyz',\n    )\n  }\n  return {\n    depositAddr: res.depositAddr,\n    solanaAddr: res.solanaAddr,\n  }\n}\n", "import type { Address, Hex } from 'viem'\n\nimport type { ApiCheckoutClientMetadata } from '@funkit/utils'\nimport type { BaseApiRequest } from '../../consts'\nimport type { UserOperation } from '../fw-operation'\n\n// The params required for the actual /checkout/quote api\nexport type CheckoutApiQuoteParams = {\n  fromChainId: string\n  fromTokenAddress: Address\n  toChainId: string\n  toTokenAddress: Address\n  toAmountBaseUnit: string\n  /** @deprecated */\n  checkoutExpirationTimestampSeconds: string\n  sponsorInitialTransferGasLimit: string\n  userId: string\n  recipientAddr?: Address\n}\n\nexport type CheckoutQuoteParams = BaseApiRequest &\n  Omit<\n    CheckoutApiQuoteParams,\n    'toAmountBaseUnit' | 'checkoutExpirationTimestampSeconds'\n  > & {\n    fromTokenDecimals: number\n    toTokenDecimals: number\n    toTokenAmount: number\n    /** @deprecated */\n    expirationTimestampMs?: number\n  }\n\n/**===============*\n * CHECKOUT INIT  *\n *================*/\n\nexport type CheckoutApiInitParams = {\n  userOp?: UserOperation\n  quoteId: string\n  sourceOfFund: string\n  salt: Hex\n  // TODO: Proper typing wrt _generateClientMetadata() logic\n  clientMetadata: object\n}\n\nexport type CheckoutInitParams = BaseApiRequest &\n  Omit<CheckoutApiInitParams, 'salt'>\n\nexport type CheckoutInitResponse = {\n  depositAddr: Address\n}\n\nexport type CheckoutInitTokenTransferResponse = CheckoutInitResponse & {\n  solanaAddr?: SolanaAddress\n}\n\n/**=====================*\n * CHECKOUT DEACTIVATE  *\n *======================*/\n\nexport type CheckoutDeactivateParams = BaseApiRequest & {\n  depositAddress: Address\n}\n\n// Reference from api server: https://github.com/fun-xyz/fun-api-server/blob/main/src/tables/FunWalletCheckout.ts#L11C1-L21C2\nexport enum CheckoutState {\n  // In-progress States\n  FROM_UNFUNDED = 'FROM_UNFUNDED',\n  FROM_FUNDED = 'FROM_FUNDED',\n  FROM_POOLED = 'FROM_POOLED',\n  TO_UNFUNDED = 'TO_UNFUNDED',\n  TO_FUNDED = 'TO_FUNDED',\n  TO_POOLED = 'TO_POOLED',\n  TO_READY = 'TO_READY',\n  PENDING_RECEIVAL = 'PENDING_RECEIVAL',\n  // Terminal States\n  COMPLETED = 'COMPLETED',\n  CHECKOUT_ERROR = 'CHECKOUT_ERROR',\n  EXPIRED = 'EXPIRED',\n  CANCELLED = 'CANCELLED',\n}\n\n// Checkout state categorizations\nexport const FROM_PROGRESS_CHECKOUT_STATES = [\n  CheckoutState.FROM_UNFUNDED,\n  CheckoutState.FROM_FUNDED,\n  CheckoutState.FROM_POOLED,\n]\n\nexport const TO_PROGRESS_CHECKOUT_STATES = [\n  CheckoutState.TO_UNFUNDED,\n  CheckoutState.TO_FUNDED,\n  CheckoutState.TO_POOLED,\n  CheckoutState.TO_READY,\n  CheckoutState.PENDING_RECEIVAL,\n]\n\nexport const IN_PROGRESS_CHECKOUT_STATES = [\n  ...TO_PROGRESS_CHECKOUT_STATES,\n  ...FROM_PROGRESS_CHECKOUT_STATES,\n]\n\nexport const TERMINAL_CHECKOUT_STATES = [\n  CheckoutState.EXPIRED,\n  CheckoutState.CHECKOUT_ERROR,\n  CheckoutState.COMPLETED,\n  CheckoutState.CANCELLED,\n]\n\nexport enum CheckoutRefundState {\n  INITIATED = 'INITIATED',\n  ERROR = 'ERROR',\n  REFUNDED = 'REFUNDED',\n  PROCEEDED = 'PROCEEDED',\n  WAITING_FOR_FULFILLMENT = 'WAITING_FOR_FULFILLMENT',\n  FULFILLED = 'FULFILLED',\n}\n\nexport type CheckoutHistoryItem = {\n  createdTimeMs: number\n  depositAddr: Address\n  currentDepositAddr: Address\n  recipientAddr: Address\n  expirationTimestampSeconds: number\n  fromAmountBaseUnit: string\n  fromChainId: string\n  fromTokenAddress: Address\n  funWalletAddr: Address\n  lastUpdatedTimeMs: number\n  salt: Hex\n  state: CheckoutState\n  toAmountBaseUnit: string\n  toChainId: string\n  toTokenAddress: Address\n  userOp?: UserOperation\n  version: number\n  sourceOfFund: string\n  clientMetadata: ApiCheckoutClientMetadata\n  refundState?: CheckoutRefundState\n  // Note: Optional, because BE does not retroactively update existing CheckoutHistoryItem entries\n  stateTimestampMs?: Partial<Record<CheckoutState, number>>\n}\n\n/**===============================*\n * CHECKOUT TRANSFER SPONSORSHIP  *\n *================================*/\n\nexport type CheckoutTransferSponsorshipParams = BaseApiRequest & {\n  transferUserOp: UserOperation\n  depositAddress: Address\n}\n\nexport type CheckoutTransferSponsorshipApiParams = {\n  userOp: UserOperation\n  depositAddress: Address\n}\n\nexport type CheckoutTransferSponsorshipResponse = {\n  signerAddress: Address\n  signature: Hex\n  deadline: number\n  paymasterAndData: Hex\n}\n\n/**===============================*\n * RISK ASSESSMENT  *\n *================================*/\n\nexport type RiskAssessmentParams = BaseApiRequest & {\n  address: FunAddress\n}\n\ntype AddressIdentification = {\n  name: string\n  address: FunAddress\n  category: string\n  description: string\n  url: string | null\n  createdAt: number\n}\n\ntype Cluster = {\n  name: string\n  category: string\n}\n\nexport type RiskValues = 'Severe' | 'High' | 'Medium' | 'Low'\n\ntype ExposureType = 'direct' | 'indirect'\n\ntype Exposure = {\n  category: string\n  value: number\n  exposureType: ExposureType\n  direction: string\n}\n\ntype RiskTrigger = {\n  risk: string\n  minThreshold: number\n  maxThreshold: number\n  exposureType: string\n  direction: string\n}\n\ntype Trigger = {\n  category: string\n  percentage: number\n  message: string\n  ruleTriggered?: RiskTrigger\n}\n\ntype PoolMetadata = {\n  fees?: number\n  tokens: string[]\n}\n\n// fun.xyz uses `dydx${address}` for dydx addresses as VIP addr :/\nexport type DydxAddress = `dydx${string}`\nexport type SolanaAddress = string // TODO: Proper typing from a package\nexport type FunAddress = Address | DydxAddress | SolanaAddress\n\nexport type RiskAssessmentResponse = {\n  address: FunAddress\n  risk: RiskValues\n  riskReason: string | null\n  cluster?: Cluster\n  addressType: string\n  addressIdentifications: AddressIdentification[]\n  exposures: Exposure[]\n  triggers: Trigger[]\n  status: string\n  poolMetadata: PoolMetadata\n}\n\nexport type CheckoutInitTokenTransferAddressParams = BaseApiRequest & {\n  toChainId: string\n  toTokenAddress: Address\n  userId: string\n  clientMetadata: NonNullable<object>\n  sourceOfFund?: string\n  recipientAddr: string\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  DirectExecution,\n  GetDirectExecutionByTxHashRequest,\n  GetDirectExecutionsByUserIdRequest,\n  PostDirectExecutionRequest,\n} from './types'\n\nexport async function getDirectExecutionByTxHash({\n  txHash,\n  apiKey,\n  logger,\n  signal,\n}: GetDirectExecutionByTxHashRequest): Promise<DirectExecution> {\n  return sendGetRequest<DirectExecution>({\n    uri: `${API_BASE_URL}/direct-execution/${txHash}`,\n    apiKey,\n    logger,\n    signal,\n  })\n}\n\nexport async function getDirectExecutionsByUserId({\n  userId,\n  apiKey,\n  logger,\n  limit,\n  signal,\n}: GetDirectExecutionsByUserIdRequest): Promise<DirectExecution[]> {\n  const query = limit\n    ? new URLSearchParams({\n        limit: limit.toString(),\n      })\n    : ''\n  return sendGetRequest<DirectExecution[]>({\n    uri: `${API_BASE_URL}/direct-execution/userId/${userId}?${query}`,\n    apiKey,\n    logger,\n    signal,\n  })\n}\n\nexport async function createDirectExecution({\n  txHash,\n  userId,\n  recipientAddr,\n  fromChainId,\n  fromTokenAddress,\n  toChainId,\n  toTokenAddress,\n  fromAmountBaseUnit,\n  toAmountBaseUnit,\n  estTotalUsd,\n  sourceOfFund,\n  clientMetadata,\n  apiKey,\n  logger,\n  signal,\n  type,\n}: PostDirectExecutionRequest): Promise<{ txHash: DirectExecution['txHash'] }> {\n  const body = {\n    txHash,\n    sourceOfFund,\n    userId,\n    recipientAddr,\n    fromChainId,\n    fromTokenAddress,\n    toChainId,\n    toTokenAddress,\n    fromAmountBaseUnit,\n    toAmountBaseUnit,\n    estTotalUsd,\n    clientMetadata,\n    type,\n  }\n\n  return sendPostRequest<{ txHash: DirectExecution['txHash'] }>({\n    uri: `${API_BASE_URL}/direct-execution`,\n    body,\n    apiKey,\n    logger,\n    signal,\n  })\n}\n", "import type { ApiCheckoutClientMetadata } from '@funkit/utils'\nimport type { Address, Hex } from 'viem'\nimport type { BaseApiRequest } from '../../consts'\n\nexport interface GetDirectExecutionByTxHashRequest extends BaseApiRequest {\n  txHash: Hex\n}\n\nexport interface GetDirectExecutionsByUserIdRequest extends BaseApiRequest {\n  userId: string\n  limit?: number\n}\n\n// Reference: https://github.com/fun-xyz/fun-backend/blob/main/packages/types/src/system/direct-execution.ts#L1\nexport enum DirectExecutionType {\n  TEST_EXECUTION = 'TEST_EXECUTION', // For UT purposes only, should never show up in prod table\n  /** @deprecated All vertex direct exec flows will go to Relay now */\n  VERTEX_DEPOSIT_COLLATERAL_WITH_REFERRAL = 'VERTEX_DEPOSIT_COLLATERAL_WITH_REFERRAL', // Vertex deposit collateral with referral\n  RELAY = 'RELAY', // Relay checkout UI execution\n}\n\n// Reference: https://github.com/reservoirprotocol/relay-kit/blob/211c645f9702a3b459ff545aa4e2e9d536c38455/packages/sdk/src/types/Execute.ts#L54-L61\nexport enum RelayExecutionStatus {\n  DELAYED = 'delayed',\n  FAILURE = 'failure',\n  PENDING = 'pending',\n  REFUND = 'refund',\n  SUCCESS = 'success',\n  WAITING = 'waiting',\n  UNKNOWN = 'unknown',\n}\n\nexport interface RelayExecutionRequestFeeData {\n  fees: Fee\n  feesUsd: Fee\n}\n\nexport interface Fee {\n  gas: bigint\n  fixed: bigint\n  price: bigint\n}\n\n// Reference: https://github.com/fun-xyz/fun-backend/blob/main/packages/types/src/system/tables/DirectExecution.ts#L7\nexport interface DirectExecution {\n  txHash: Hex\n  customerId: string\n  userId: string\n  recipientAddr: Address\n  type: DirectExecutionType\n\n  fromChainId: string\n  fromTokenAddress: Address\n  toChainId: string\n  toTokenAddress: Address\n\n  fromAmountBaseUnit: string\n  toAmountBaseUnit: string\n  estTotalUsd: number\n\n  sourceOfFund: string\n  clientMetadata: ApiCheckoutClientMetadata\n  createdTimeMs: number\n  updatedTimeMs?: number\n\n  listenerInfo?: {\n    status: RelayExecutionStatus\n    inTxHashes: string[]\n    txHashes: string[]\n    time: number\n    originChainId: number\n    destinationChainId: number\n    relayExecutionRequestDetails?: {\n      id: Hex\n      status: RelayExecutionStatus\n      createdAt: Date\n      updatedAt: Date\n      data: RelayExecutionRequestFeeData\n    }\n  }\n}\n\nexport interface PostDirectExecutionRequest\n  extends BaseApiRequest,\n    Omit<DirectExecution, 'customerId' | 'createdTimeMs'> {}\n", "import { FUN_FAUCET_URL } from '../../consts'\nimport { sendGetRequest } from '../../utils'\nimport type { GetAssetFromFaucetRequest } from './types'\n\nexport async function getAssetFromFaucet({\n  token,\n  chain,\n  walletAddress,\n  ...options\n}: GetAssetFromFaucetRequest) {\n  return await sendGetRequest({\n    uri: `${FUN_FAUCET_URL}/get-faucet?token=${token}&testnet=${chain}&addr=${walletAddress}`,\n    ...options,\n  })\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  CheckWalletAccessInitializationRequest,\n  InitializeWalletAccessRequest,\n} from './types'\n\nexport async function initializeWalletAccess({\n  walletAddr,\n  creatorAddr,\n  ...options\n}: InitializeWalletAccessRequest): Promise<void> {\n  await sendPostRequest({\n    uri: `${API_BASE_URL}/access/wallet`,\n    body: { walletAddr, creatorAddr },\n    ...options,\n  })\n}\n\nexport async function checkWalletAccessInitialization({\n  walletAddr,\n  ...options\n}: CheckWalletAccessInitializationRequest): Promise<boolean> {\n  return (\n    await sendGetRequest<{ initialized: boolean }>({\n      uri: `${API_BASE_URL}/access/wallet/${walletAddr}`,\n      ...options,\n    })\n  ).initialized\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendPostRequest } from '../../utils'\nimport type { GetGroupsRequest, GroupMetadata } from './types'\n\nexport async function getGroups({\n  groupIds,\n  chainId,\n  ...options\n}: GetGroupsRequest): Promise<GroupMetadata[]> {\n  return (\n    await sendPostRequest<{ groups: GroupMetadata[] }>({\n      uri: `${API_BASE_URL}/group/get-groups`,\n      body: { groupIds, chainId },\n      ...options,\n    })\n  ).groups\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendGetRequest } from '../../utils'\nimport type {\n  GetChainFromIdRequest,\n  GetChainFromNameRequest,\n  ServerChainInfo,\n} from './types'\n\nexport async function getChainFromId({\n  chainId,\n  ...options\n}: GetChainFromIdRequest): Promise<ServerChainInfo> {\n  const res = await sendGetRequest<ServerChainInfo>({\n    uri: `${API_BASE_URL}/chain-info/${chainId}`,\n    ...options,\n  })\n  if (!res) {\n    throw new Error(JSON.stringify(res))\n  }\n  return res\n}\n\nexport async function getChainFromName({\n  name,\n  ...options\n}: GetChainFromNameRequest): Promise<ServerChainInfo> {\n  const res = await sendGetRequest<ServerChainInfo>({\n    uri: `${API_BASE_URL}/chain-info?name=${name}`,\n    ...options,\n  })\n  if (!res) {\n    throw new Error(JSON.stringify(res))\n  }\n  return res\n}\n", "import type { Address } from 'viem'\nimport { API_BASE_URL } from '../../consts'\nimport { sendDeleteRequest, sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  CreateOpRequest,\n  DeleteOpRequest,\n  EstimateOpInput,\n  EstimatedGas,\n  ExecuteOpInput,\n  ExecutionReceipt,\n  GetFullReceiptRequest,\n  GetOpsOfWalletRequest,\n  GetOpsRequest,\n  GetUserOpGasPriceRequest,\n  OpRequest,\n  OperationData,\n  ScheduleOpInput,\n  SignOpRequest,\n  UserOperationGasPrice,\n} from './types'\n\nexport async function createOp({\n  op,\n  ...options\n}: CreateOpRequest): Promise<string> {\n  return (\n    await sendPostRequest<{ opId: string }>({\n      uri: `${API_BASE_URL}/operation`,\n      body: { ...op },\n      ...options,\n    })\n  ).opId\n}\n\ninterface OpsOfWalletResponse {\n  operations: OperationData[]\n}\n\nexport async function getOpsOfWallet({\n  walletAddr,\n  chainId,\n  status,\n  ...options\n}: GetOpsOfWalletRequest): Promise<OperationData[]> {\n  const endpoint = status\n    ? `${API_BASE_URL}/operation/wallet/${walletAddr}/chain/${chainId}?status=${status}`\n    : `${API_BASE_URL}/operation/wallet/${walletAddr}/chain/${chainId}`\n  return (\n    await sendGetRequest<OpsOfWalletResponse>({ uri: endpoint, ...options })\n  ).operations\n}\n\nexport async function getOps({\n  opIds,\n  chainId,\n  ...options\n}: GetOpsRequest): Promise<OperationData[]> {\n  return (\n    await sendPostRequest<OpsOfWalletResponse>({\n      uri: `${API_BASE_URL}/operation/get-operations`,\n      body: {\n        opIds,\n        chainId,\n      },\n      ...options,\n    })\n  ).operations\n}\n\nexport async function deleteOp({\n  opId,\n  chainId,\n  ...options\n}: DeleteOpRequest): Promise<void> {\n  await sendDeleteRequest({\n    uri: `${API_BASE_URL}/operation/${opId}/chain/${chainId}`,\n    ...options,\n  })\n}\n\nexport async function signOp({\n  opId,\n  chainId,\n  signature,\n  signedBy,\n  threshold,\n  ...options\n}: SignOpRequest): Promise<void> {\n  await sendPostRequest({\n    uri: `${API_BASE_URL}/operation/sign`,\n    body: {\n      opId,\n      chainId,\n      signature,\n      signedBy,\n      threshold,\n    },\n    ...options,\n  })\n}\n\nexport async function executeOp({\n  input,\n  ...options\n}: OpRequest<ExecuteOpInput>): Promise<ExecutionReceipt> {\n  return await sendPostRequest({\n    uri: `${API_BASE_URL}/operation/execute`,\n    body: input,\n    ...options,\n  })\n}\n\nexport async function estimateOp({\n  input,\n  ...options\n}: OpRequest<EstimateOpInput>): Promise<EstimatedGas> {\n  return await sendPostRequest({\n    uri: `${API_BASE_URL}/operation/estimate`,\n    body: input,\n    ...options,\n  })\n}\n\nexport async function scheduleOp({\n  input,\n  ...options\n}: OpRequest<ScheduleOpInput>): Promise<void> {\n  await sendPostRequest({\n    uri: `${API_BASE_URL}/operation/schedule`,\n    body: input,\n    ...options,\n  })\n}\n\nexport const getFullReceipt = async ({\n  opId,\n  chainId,\n  userOpHash,\n  ...options\n}: GetFullReceiptRequest): Promise<ExecutionReceipt> => {\n  const retries = 20\n  let result: { status: string; receipt?: ExecutionReceipt } = {\n    status: 'pending',\n  }\n  for (let i = 0; i < retries; i++) {\n    try {\n      result = await sendGetRequest({\n        uri: `${API_BASE_URL}/operation/${opId}/chain/${chainId}/receipt?userOpHash=${userOpHash}`,\n        ...options,\n      })\n      if (result.status === 'included') {\n        break\n      }\n    } catch (_err) {\n      /* empty */\n    }\n\n    await new Promise((resolve) => setTimeout(resolve, 2500))\n  }\n  if (!result.receipt) {\n    result.receipt = {\n      // TODO: this is obviously wrong but it was what we had before\n      txId: 'Failed to find.' as Address,\n      gasUsed: 'Failed to find.',\n      opFeeUSD: 'Failed to find.',\n      opFee: 'Failed to find.',\n      userOpHash: 'Failed to find.',\n    }\n  }\n  return {\n    ...result.receipt,\n  }\n}\n\nexport const getUserOpGasPrice = async ({\n  chainId,\n  ...options\n}: GetUserOpGasPriceRequest): Promise<UserOperationGasPrice> => {\n  return await sendGetRequest({\n    uri: `${API_BASE_URL}/operation/chain/${chainId}/gas-price`,\n    ...options,\n  })\n}\n", "import type { Address, Hex } from 'viem'\n\nimport type { BaseApiRequest } from '../../consts'\n\nexport enum OperationStatus {\n  ALL = '',\n  PENDING_APPROVED = 'PENDING_APPROVED',\n  APPROVED = 'APPROVED',\n  PENDING = 'PENDING',\n  OP_SUCCEED = 'OP_SUCCEED',\n  OP_REVERTED = 'OP_REVERTED',\n  SCHEDULED = 'SCHEDULED',\n}\n\nexport type OperationMetadata = {\n  opId?: Hex\n  chainId: string\n  opType: OperationType\n  authType: AuthType\n  groupId?: Hex\n  message?: string\n  walletAddr: Address\n  status?: OperationStatus\n  proposer: string // do not use address in case we later use non-address data as the proposer\n  proposedTime?: number\n  executedBy?: string\n  executedTime?: number\n  relatedOpIds?: Hex[]\n  signatures?: Signature[]\n  txid?: string\n  gasUsed?: string\n  opFeeUSD?: string\n  opFee?: string\n  executedBlockNumber?: number\n  executedBlockTimeStamp?: number\n}\n\nexport interface OperationData extends OperationMetadata {\n  userOp: UserOperation\n}\n\nexport enum AuthType {\n  ECDSA = 0,\n  MULTI_SIG = 1,\n}\n\nexport type Signature = {\n  userId: Hex\n  signature: Hex\n  signedTime: number\n}\n\nexport enum OperationType {\n  SINGLE_OPERATION = 'SINGLE_OPERATION',\n  GROUP_OPERATION = 'GROUP_OPERATION',\n  REJECTION = 'REJECTION',\n}\n\nexport type GroupInfo = {\n  threshold: number\n  memberIds: Hex[]\n}\n\nexport type UserOperation = {\n  sender: string\n  nonce: bigint\n  initCode?: string\n  callData: string\n  callGasLimit: bigint\n  verificationGasLimit: bigint\n  preVerificationGas?: bigint\n  maxFeePerGas: bigint\n  maxPriorityFeePerGas: bigint\n  paymasterAndData?: string\n  signature?: string\n}\n\nexport interface ExecutionReceipt {\n  userOpHash: string\n  txId?: Hex\n  gasUsed?: string\n  opFeeUSD?: string\n  opFee?: string\n}\n\nexport type EstimatedGas = {\n  preVerificationGas: bigint\n  callGasLimit: bigint\n  verificationGasLimit: bigint\n}\n\nexport interface CreateOpRequest extends BaseApiRequest {\n  op: OperationData\n}\n\nexport interface GetOpsOfWalletRequest extends BaseApiRequest {\n  walletAddr: Address\n  chainId: string\n  status?: OperationStatus\n}\n\nexport interface GetOpsRequest extends BaseApiRequest {\n  opIds: Hex[]\n  chainId: string\n}\n\nexport interface DeleteOpRequest extends BaseApiRequest {\n  opId: Hex\n  chainId: string\n}\n\nexport interface SignOpRequest extends BaseApiRequest {\n  opId: Hex\n  chainId: string\n  signature: Hex\n  signedBy: Address\n  threshold?: number\n}\n\nexport type OpRequest<T> = BaseApiRequest & {\n  input: T\n}\n\nexport type ExecuteOpInput = {\n  opId: Hex\n  chainId: string\n  executedBy: string\n  entryPointAddress: Address\n  signature: Hex\n  userOp?: UserOperation\n  groupInfo?: GroupInfo\n}\n\nexport type EstimateOpInput = {\n  opId?: Hex\n  chainId: string\n  entryPointAddress?: Address\n  signature?: Hex\n  userOp?: UserOperation\n}\n\nexport type ScheduleOpInput = {\n  opId: Hex\n  chainId: string\n  scheduledBy: string\n  entryPointAddress: Address\n  signature: Hex\n  userOp?: UserOperation\n  groupInfo?: GroupInfo\n}\n\nexport interface GetFullReceiptRequest extends BaseApiRequest {\n  opId: string\n  chainId: string\n  userOpHash: string\n}\n\nexport interface GetUserOpGasPriceRequest extends BaseApiRequest {\n  chainId: string\n}\n\nexport type UserOperationGasPrice = {\n  maxFeePerGas: bigint\n  maxPriorityFeePerGas: bigint\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendPostRequest } from '../../utils'\nimport type { AddPaymasterTransactionRequest } from './types'\n\nexport async function addTransaction({\n  chainId,\n  timestamp,\n  txid,\n  transaction,\n  paymasterType,\n  sponsorAddress,\n  ...options\n}: AddPaymasterTransactionRequest): Promise<any> {\n  try {\n    return await sendPostRequest({\n      uri: `${API_BASE_URL}/dashboard/paymasters/add-transaction`,\n      body: {\n        chain: chainId,\n        sponsorAddress,\n        type: paymasterType,\n        timestamp,\n        transaction,\n        txid,\n      },\n      ...options,\n    })\n  } catch (_err) {\n    /* empty */\n  }\n}\n", "import type { BaseApiRequest } from '../../consts'\nimport type { ExecutionReceipt } from '../fw-operation'\n\nexport interface PaymasterTransaction {\n  action: string\n  amount: number\n  from: string\n  to: string\n  token: string\n  txid?: string\n}\n\nexport interface AddPaymasterTransactionRequest extends BaseApiRequest {\n  chainId: string\n  timestamp: number\n  txid: ExecutionReceipt['txId'] | string\n  transaction: PaymasterTransaction\n  paymasterType: PaymasterType\n  sponsorAddress: string\n}\n\nexport enum PaymasterType {\n  BaseSponsor = 'base',\n  GaslessSponsor = 'gasless',\n  TokenSponsor = 'token',\n  CheckoutSponsor = 'checkout',\n}\n", "import { ResourceNotFoundError } from '@funkit/utils'\nimport { type Hex, InvalidParameterError } from 'viem'\nimport { API_BASE_URL } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  AddUserToWalletRequest,\n  CreateUserRequest,\n  GetUserUniqueIdRequest,\n  GetUserWalletIdentitiesRequest,\n  GetUserWalletsByAddrRequest,\n  Wallet,\n} from './types'\n\nexport async function createUser({\n  authId,\n  addr,\n  method,\n  userUniqueId,\n  ...options\n}: CreateUserRequest): Promise<void> {\n  await sendPostRequest({\n    uri: `${API_BASE_URL}/user`,\n    body: {\n      authId,\n      addr,\n      method,\n      userUniqueId,\n    },\n    ...options,\n  })\n}\n\nexport async function getUserUniqueId({\n  authId,\n  ...options\n}: GetUserUniqueIdRequest): Promise<string> {\n  try {\n    return (\n      await sendGetRequest<{ userUniqueId: string }>({\n        uri: `${API_BASE_URL}/user/auth/${authId}/unique-id`,\n        ...options,\n      })\n    ).userUniqueId\n  } catch (err) {\n    if (err instanceof ResourceNotFoundError) {\n      return ''\n    }\n    throw err\n  }\n}\n\nexport async function getUserWalletsByAddr({\n  addr,\n  chainId,\n  ...options\n}: GetUserWalletsByAddrRequest): Promise<Wallet[]> {\n  const endpoint = chainId\n    ? `${API_BASE_URL}/user/addr/${addr}/wallets?chainId=${chainId}`\n    : `${API_BASE_URL}/user/addr/${addr}/wallets`\n  return (\n    await sendGetRequest<{ wallets: Wallet[] }>({ uri: endpoint, ...options })\n  ).wallets\n}\n\nexport async function addUserToWallet({\n  authId,\n  chainId,\n  walletAddr,\n  userIds,\n  walletUniqueId,\n  ...options\n}: AddUserToWalletRequest): Promise<void> {\n  try {\n    await sendPostRequest({\n      uri: `${API_BASE_URL}/user/auth/${authId}/chain/${chainId}/wallet`,\n      body: { walletAddr, userIds, walletUniqueId },\n      ...options,\n    })\n  } catch (err) {\n    if (err instanceof InvalidParameterError) {\n      // TODO: What about any other cause of InvalidParameterError???\n      // swallow the error if the wallet already exists.\n      return\n    }\n\n    throw err\n  }\n}\n\n/**\n * @returns userIds of the specified Wallet.\n */\nexport async function getUserWalletIdentities({\n  authId,\n  chainId,\n  walletAddr,\n  ...options\n}: GetUserWalletIdentitiesRequest): Promise<Hex[]> {\n  return (\n    (\n      await sendGetRequest<{ ids: Hex[] }>({\n        uri: `${API_BASE_URL}/user/auth/${authId}/chain/${chainId}/wallet/${walletAddr}/identities`,\n        ...options,\n      })\n    ).ids ?? []\n  )\n}\n", "import { type BaseApiRequest, MESH_API_BASE_URL } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  GetCryptoPurchaseLimitsParams,\n  MeldCreateCryptoQuoteParams,\n  MeldCreateCryptoQuoteResponse,\n  MeldCreateCryptoWidgetParams,\n  MeldCreateCryptoWidgetResponse,\n  MeldDefaultFiatResponse,\n  MeldFiatLimitResponse,\n  MeldSupportedFiatResponse,\n  SearchDefaultFiatParams,\n} from './types'\n\nexport async function getMeldSupportedFiat({\n  ...options\n}: BaseApiRequest): Promise<MeldSupportedFiatResponse> {\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/meld/fiat`,\n    ...options,\n    retryOptions: { maxAttempts: 2 },\n  })\n}\n\nexport async function getMeldQuotes({\n  params,\n  ...options\n}: BaseApiRequest & {\n  params: MeldCreateCryptoQuoteParams\n}): Promise<MeldCreateCryptoQuoteResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/api/meld/quote`,\n    body: params,\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n}\n\nexport async function startMeldSession({\n  params,\n  ...options\n}: BaseApiRequest & {\n  params: MeldCreateCryptoWidgetParams['sessionData']\n}): Promise<MeldCreateCryptoWidgetResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/api/meld/session`,\n    body: {\n      sessionData: params,\n      sessionType: 'BUY',\n    },\n    retryOptions: { maxAttempts: 2 },\n    ...options,\n  })\n}\n\nexport async function getMeldDefaultFiat({\n  params,\n  ...options\n}: BaseApiRequest & {\n  params: SearchDefaultFiatParams\n}): Promise<MeldDefaultFiatResponse> {\n  const countries = params.countries?.join(',') ?? ''\n  const categories = params.categories?.join(',') ?? ''\n  const urlParams = new URLSearchParams({\n    ...(countries ? { countries } : {}),\n    ...(categories ? { categories } : {}),\n  })\n\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/meld/defaultFiat?${urlParams}`,\n    ...options,\n    retryOptions: { maxAttempts: 2 },\n  })\n}\n\nexport async function getMeldFiatLimits({\n  params,\n  ...options\n}: BaseApiRequest & {\n  params: GetCryptoPurchaseLimitsParams\n}): Promise<MeldFiatLimitResponse> {\n  const countries = params.countries.join(',')\n  const cryptoCurrencies = params.cryptoCurrencies.join(',')\n  const fiatCurrencies = params.fiatCurrencies.join(',')\n  const categories = params.categories?.join(',') ?? ''\n  const urlParams = new URLSearchParams({\n    countries,\n    cryptoCurrencies,\n    fiatCurrencies,\n    ...(categories ? { categories } : {}),\n  })\n\n  return sendGetRequest({\n    uri: `${MESH_API_BASE_URL}/api/meld/fiatLimit?${urlParams}`,\n    ...options,\n    retryOptions: { maxAttempts: 2 },\n  })\n}\n", "export enum MeldServiceProvider {\n  ALCHEMYPAY = 'ALCHEMYPAY',\n  BANXA = 'BANXA',\n  BILIRA = 'BILIRA',\n  BINANCECONNECT = 'BINANCECONNECT',\n  BLOCKCHAINDOTCOM = 'BLOCKCHAINDOTCOM',\n  BTCDIRECT = 'BTCDIRECT',\n  COINBASEPAY = 'COINBASEPAY',\n  FONBNK = 'FONBNK',\n  GUARDARIAN = 'GUARDARIAN',\n  KOYWE = 'KOYWE',\n  MERCURYO = 'MERCURYO',\n  MESH = 'MESH',\n  MESO = 'MESO',\n  ONMETA = 'ONMETA',\n  ONRAMPMONEY = 'ONRAMPMONEY',\n  PAYBIS = 'PAYBIS',\n  PAYPAL = 'PAYPAL',\n  RAMP = 'RAMP',\n  ROBINHOOD = 'ROBINHOOD',\n  SARDINE = 'SARDINE',\n  SHIFT4 = 'SHIFT4',\n  SIMPLEX = 'SIMPLEX',\n  SKRILLCRYPTO = 'SKRILLCRYPTO',\n  STRIPE = 'STRIPE',\n  TOPPER = 'TOPPER',\n  TRANSAK = 'TRANSAK',\n  TRANSFI = 'TRANSFI',\n  UNLIMIT = 'UNLIMIT',\n  YELLOWCARD = 'YELLOWCARD',\n}\n\nexport const MELD_PROVIDER_CATEGORIES = [\n  'BANK_LINKING',\n  'CRYPTO_ONRAMP',\n  'CRYPTO_OFFRAMP',\n  'CRYPTO_TRANSFER',\n  'FIAT_PAYMENTS',\n] as const\n\nexport type MeldFiatCurrency = {\n  /** fiat code. e.g. USD/EUR */\n  currencyCode: string\n  /** fiat name. e.g. United State Dollar */\n  name: string\n  /** image URL for the currency symbol provided by meld */\n  symbolImageUrl: string\n}\n\nexport type MeldDefaultFiatCurrency = {\n  /** Two-letter code (ISO 3166-1 alpha-2) for the Country. */\n  countryCode: string\n  /** fiat code. e.g. USD/EUR */\n  defaultCurrencyCode: string\n  /** The identifier for the Payment Method */\n  defaultPaymentMethods: MeldQuote['paymentMethodType'][]\n}\n\nexport type MeldCreateCryptoQuoteParams = {\n  /**\n   * Two-letter country code (ISO 3166-1 alpha-2)\n   */\n  countryCode: string\n\n  /**\n   * Meld generated unique identifier for your customer. This should be used to track customer activity.\n   */\n  customerId?: string\n\n  /**\n   * The cryptocurrency the customer is buying (e.g. BTC, ETH).\n   */\n  destinationCurrencyCode: string\n\n  /**\n   * Your unique identifier for your customer. If maintaining your own customer management system this can also be used for tracking customer activity.\n   */\n  externalCustomerId?: string\n\n  /**\n   * Payment Method Type or SubType\n   */\n  paymentMethodType?: string\n\n  /**\n   * An optional list of Strings representing the Service Providers for this Quote\n   */\n  serviceProviders?: MeldServiceProvider[]\n\n  /**\n   * The amount of source currency your customer wants tosend in this transaction (e.g., 50.05)\n   */\n  sourceAmount: `${number}`\n\n  /**\n   * The fiat currency the user is buying crypto with (e.g. USD, EUR)\n   */\n  sourceCurrencyCode: string\n\n  /**\n   * Subdivision is a optional parameter Only applicable if the country code is US or CA (e.g. US-CA).\n   */\n  subdivision?: string\n\n  /**\n   * Your customer's wallet address\n   */\n  walletAddress?: `0x${string}`\n}\n\nexport type MeldQuote = {\n  /**\n   * Two-letter country code (ISO 3166-1 alpha-2)\n   */\n  countryCode: string\n\n  /**\n   * A numerical score representing the expectation a Customer will convert\n   */\n  customerScore?: number\n\n  /**\n   * Destination currency amount to be received for this quote\n   */\n  destinationAmount: number\n\n  /**\n   * Code of currency being quoted: BTC, ETH, ...\n   */\n  destinationCurrencyCode: string\n\n  /**\n   * The exchange rate at the time the request is sent\n   */\n  exchangeRate: number\n\n  /**\n   * The fiat amount exchanged when buying or selling crypto, excluding fees\n   */\n  fiatAmountWithoutFees: number\n\n  /**\n   * The name of the institution or broker used for this quote, if present\n   */\n  institutionName?: string | null\n\n  /**\n   * LowKYC indicates if the quote amount is below the provider's low KYC threshold, meaning the user may not need to upload documents, which can increase conversion.\n   */\n  lowKyc?: boolean | null\n\n  /**\n   * The network fee applied to a crypto transaction\n   */\n  networkFee?: number | null\n\n  /**\n   * The fee amount charged by the partner to process your customer's purchase\n   */\n  partnerFee?: number | null\n\n  /**\n   * Payment Method Type used for this quote\n   */\n  paymentMethodType: 'APPLE_PAY' | 'MASTERCARD' | 'SEPA' | 'VISA'\n\n  /**\n   * The service provider used for this transaction\n   */\n  serviceProvider: MeldServiceProvider\n\n  /**\n   * Amount requested + fees\n   */\n  sourceAmount: number\n\n  /**\n   * The fiat currency the user is buying crypto with (e.g. USD, EUR)\n   */\n  sourceCurrencyCode: string\n\n  /**\n   * The total amount of fees that will be charged\n   */\n  totalFee?: number | null\n\n  /**\n   * The fee amount charged by the service provider to process your customer's purchase\n   */\n  transactionFee?: number | null\n\n  /**\n   * The type of crypto transaction\n   */\n  transactionType: 'CRYPTO_PURCHASE' // | 'CRYPTO_SELL', but only care about buying atm\n}\n\nexport type MeldCreateCryptoQuoteResponse = {\n  quotes: MeldQuote[]\n}\n\nexport type MeldCreateCryptoWidgetParams = {\n  /**\n   * Meld generated unique identifier for your customer. This should be used to track customer activity.\n   */\n  customerId?: string\n\n  /**\n   * Your unique identifier for your customer. If maintaining your own customer management system this can also be used for tracking customer activity.\n   */\n  externalCustomerId?: string\n\n  /**\n   * Your reference Id for your widget session\n   */\n  externalSessionId?: string\n\n  sessionData: {\n    /**\n     * Two-letter country code (ISO 3166-1 alpha-2)\n     */\n    countryCode: string\n\n    /**\n     * The cryptocurrency the customer is buying (e.g. BTC, ETH).\n     */\n    destinationCurrencyCode: string\n\n    /**\n     * If provided, the institution to bypass the institution selection screen in the service provider's widget. Currently this is only supported for MESH widget sessions.\n     */\n    institutionId?: string\n\n    /**\n     * Where supported by the Service Provider, Meld can help you lock the cryptocurrency and/or wallet address fields within the widget.\n     */\n    lockFields?: ('destinationCurrencyCode' | 'walletAddress')[]\n\n    /**\n     * Payment Method Type or SubType\n     */\n    paymentMethodType?: string\n\n    /**\n     * The url to redirect to following completion of the widget flow\n     */\n    redirectUrl?: string\n\n    /**\n     * The service provider used for this transaction\n     */\n    serviceProvider: MeldServiceProvider\n\n    /**\n     * The amount of source currency your customer wants to send in this transaction (e.g., 50.05)\n     */\n    sourceAmount: `${number}`\n\n    /**\n     * The fiat currency the user is buying crypto with (e.g. USD, EUR)\n     */\n    sourceCurrencyCode: string\n\n    /**\n     * Your customer's wallet address\n     */\n    walletAddress: `0x${string}`\n\n    /**\n     * Your customer's wallet tag/destination tag/memo. This field is required for certain cryptocurrencies.\n     */\n    walletTag?: string\n  }\n\n  sessionType: 'BUY' // | 'SELL' | 'TRANSFER' - We only care about BUY atm\n\n  /**\n   * For MESH only. Details about a previously authenticated crypto session or bank-linking connection.\n   * If provided, the widget will not require the customer to authenticate again as long as the authentication is still valid.\n   * The scope of these authentication bypass details are restricted to the same customer, service provider, and institution that were used in the original connection.\n   */\n  authenticationBypassDetails?: {\n    /**\n     * The widget type associated with the previously authenticated session/connection.\n     */\n    category: string\n\n    /**\n     * The Meld id of the crypto session or bank-linking connection in which the customer has already authenticated with their institution.\n     * The auth tied to this session/connection will be used to bypass the authentication process for the current session, if it is still valid.\n     * This id may pertain to the initial session/connection in which the customer authenticated, or any subsequent session that used this prior authentication successfully.\n     */\n    previouslyAuthenticatedId: string\n  }\n}\n\nexport type MeldCreateCryptoWidgetResponse = {\n  /**\n   * Meld generated unique identifier for your customer. This should be used to track customer activity.\n   */\n  customerId?: string | null\n\n  /**\n   * Your unique identifier for your customer. If maintaining your own customer management system this can also be used for tracking customer activity.\n   */\n  externalCustomerId?: string | null\n\n  /**\n   * Your reference Id for your widget session\n   */\n  externalSessionId?: string | null\n\n  /**\n   * Unique identifier for this session\n   */\n  id: string\n\n  /**\n   * The session token\n   */\n  token: string\n\n  /**\n   * The crypto widget URL\n   */\n  widgetUrl: string\n}\n\nexport interface MeldError extends Error {\n  /**\n   * A categorization of the error\n   */\n  code: string\n\n  /**\n   * A user-friendly representation of the error code.\n   * This may change over time and is not safe for programmatic use.\n   */\n  errors?: string[] | null\n\n  /**\n   * A developer-friendly representation of the error code.\n   * This may change over time and is not safe for programmatic use.\n   */\n  message: string\n\n  /**\n   * The request Id\n   */\n  requestId: string\n\n  /**\n   * The date and time when the request was made (ISO)\n   */\n  timestamp: string | null\n}\n\nexport interface MeldSupportedFiatResponse {\n  currencies: MeldFiatCurrency[]\n  /** Irrelevant */\n  preferred: string[]\n}\n\nexport type SearchDefaultFiatParams = {\n  countries: string[]\n  categories?: (typeof MELD_PROVIDER_CATEGORIES)[number][]\n}\n\nexport interface MeldDefaultFiatResponse {\n  currencies: MeldDefaultFiatCurrency[]\n}\n\nexport interface GetCryptoPurchaseLimitsParams {\n  /**\n   * The two-letter country code (ISO 3166-1 alpha-2) to search for supported fiat currencies.\n   * A comma separated list of countries.\n   */\n  countries: string[]\n\n  /**\n   * The crypto currencies to search for limits\n   */\n  cryptoCurrencies: string[]\n\n  /**\n   * The fiat currencies to search for limits\n   */\n  fiatCurrencies: string[]\n\n  /**\n   * The categories to search for limits\n   */\n  categories?: (typeof MELD_PROVIDER_CATEGORIES)[number][]\n}\n\nexport interface MeldFiatCurrencyLimit {\n  currencyCode: string\n  defaultAmount: number | null\n  minimumAmount: number\n  maximumAmount: number\n}\n\nexport interface MeldFiatLimitResponse {\n  limits: MeldFiatCurrencyLimit[]\n}\n", "import {\n  API_BASE_URL,\n  type BaseApiRequest,\n  MESH_API_BASE_URL,\n} from '../../consts'\nimport { sendDeleteRequest, sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  GetCryptocurrencyHoldingsRequest,\n  GetCryptocurrencyHoldingsRequestProxy,\n  GetCryptocurrencyHoldingsResponse,\n  GetLinkTokenRequest,\n  GetLinkTokenResponse,\n  GetTransferIntegrationsRequest,\n  GetTransferIntegrationsResponse,\n  MeshConfigureTransferParams,\n  MeshConfigureTransferParamsProxy,\n  MeshConfigureTransferResponse,\n  MeshExecuteTransferRequest,\n  MeshExecuteTransferRequestProxy,\n  MeshExecuteTransferResponse,\n  PreviewTransferRequest,\n  PreviewTransferRequestProxy,\n  PreviewTransferResponse,\n} from './types'\n\n/**\n * @param authToken The authentication token to send the asset from.\n * @param type The type of the integration to send the asset from.\n * @return https://docs.meshconnect.com/api-reference/portfolio/get-holdings\n */\nexport async function meshGetCryptocurrencyHoldings({\n  authToken,\n  type,\n  ...options\n}: GetCryptocurrencyHoldingsRequest): Promise<GetCryptocurrencyHoldingsResponse> {\n  return sendPostRequest({\n    uri: `${API_BASE_URL}/mesh/holdings/get`,\n    body: { authToken, type },\n    ...options,\n  })\n}\n\nexport async function meshGetCryptocurrencyHoldingsProxy({\n  brokerType,\n  deviceId,\n  ...options\n}: GetCryptocurrencyHoldingsRequestProxy): Promise<GetCryptocurrencyHoldingsResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/mesh/holdings/get`,\n    body: { brokerType, deviceId },\n    ...options,\n  })\n}\n\n/**\n * @return https://docs.meshconnect.com/api-reference/managed-transfers/get-integrations\n */\nexport async function meshGetTransferIntegrations(\n  options: GetTransferIntegrationsRequest,\n): Promise<GetTransferIntegrationsResponse> {\n  return sendGetRequest({\n    uri: `${API_BASE_URL}/mesh/transfers/managed/integrations`,\n    ...options,\n  })\n}\n\n/**\n * @param userId A unique Id representing the end user. Typically this will be a user Id from the\nclient application. Personally identifiable information, such as an email address or phone number,\nshould not be used. 50 characters length maximum.\n * @param integrationId A unique identifier representing a specific integration obtained from the list of available integrations.\n * @param restrictMultipleAccounts The final screen of Link allows users to \u201Ccontinue\u201D back to your app or \u201CLink another account.\u201D\nIf this param is present then this button will be hidden.\n * @param transferOptions Encapsulates transaction-related parameters, including destination addresses and the amount to transfer in fiat currency.\n * @return https://docs.meshconnect.com/api-reference/managed-account-authentication/get-link-token-with-parameters\n */\nexport async function meshGetLinkToken({\n  userId,\n  integrationId,\n  restrictMultipleAccounts,\n  transferOptions,\n  ...options\n}: GetLinkTokenRequest): Promise<GetLinkTokenResponse> {\n  const body = {\n    userId,\n    ...(integrationId && { integrationId }),\n    ...(restrictMultipleAccounts && { restrictMultipleAccounts }),\n    ...(transferOptions && { transferOptions }),\n  }\n\n  return sendPostRequest({\n    uri: `${API_BASE_URL}/mesh/linktoken`,\n    body,\n    ...options,\n  })\n}\n\nexport async function meshConfigureTransfer({\n  params,\n  ...options\n}: BaseApiRequest & {\n  params: MeshConfigureTransferParams\n}): Promise<MeshConfigureTransferResponse> {\n  return sendPostRequest({\n    uri: `${API_BASE_URL}/mesh/transfers/managed/configure`,\n    body: params,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n}\n\nexport async function meshConfigureTransferProxy({\n  params,\n  ...options\n}: BaseApiRequest & {\n  params: MeshConfigureTransferParamsProxy\n}): Promise<MeshConfigureTransferResponse> {\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/mesh/transfers/managed/configure`,\n    body: params,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n}\n\n/**\n * @param fromAuthToken The authentication token to send the asset from.\n * @param fromType The type of the integration to send the asset from.\n * @param toAuthToken The authentication token of the target integration. Can be used alternatively to the address in the ToAddress field. If used, toType should also be provided.\n * @param toType The type of the target integration to send assets to. Used along with the toAuthToken alternatively to ToAddress.\n * @param networkId The network to send the asset over. This is generated by Mesh, it isn't a chainId or chain name.\n * @param symbol The symbol of the digital asset to send.\n * @param toAddress The target address to send the asset to.\n * @param amount The amount to send, in crypto.\n * @param amountInFiat The amount to send, in fiat currency. Can be used alternatively to Amount.\n * @param fiatCurrency Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to USD.\n * @returns https://docs.meshconnect.com/api-reference/managed-transfers/preview-transfer\n */\nexport async function meshPreviewTransfer({\n  fromAuthToken,\n  fromType,\n  toAuthToken,\n  toType,\n  networkId,\n  symbol,\n  toAddress,\n  amount,\n  amountInFiat,\n  fiatCurrency,\n  ...options\n}: PreviewTransferRequest): Promise<PreviewTransferResponse> {\n  const body = {\n    fromAuthToken,\n    fromType,\n    ...(toAuthToken && { toAuthToken }),\n    ...(toType && { toType }),\n    ...(networkId && { networkId }),\n    ...(symbol && { symbol }),\n    ...(toAddress && { toAddress }),\n    ...(amount && { amount }),\n    ...(amountInFiat && { amountInFiat }),\n    ...(fiatCurrency && { fiatCurrency }),\n  }\n\n  return sendPostRequest({\n    uri: `${API_BASE_URL}/mesh/transfers/managed/preview`,\n    body,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n}\n\nexport async function meshPreviewTransferProxy({\n  apiKey,\n  logger,\n  signal,\n  ...props\n}: PreviewTransferRequestProxy): Promise<PreviewTransferResponse> {\n  const body = { ...props }\n\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/mesh/transfers/managed/preview`,\n    body,\n    apiKey,\n    logger,\n    retryOptions: { maxAttempts: 1 },\n    signal,\n  })\n}\n\n/**\n *\n * @param fromAuthToken The authentication token to send the asset from.\n * @param fromType The type of the integration to send the asset from.\n * @param previewId The preview ID of the transfer to execute.\n * @param mfaCode Multi-factor auth code that should be provided if the status of the transfer was MfaRequired.\n * @returns https://docs.meshconnect.com/api-reference/managed-transfers/execute-transfer\n */\nexport async function meshExecuteTransfer({\n  fromAuthToken,\n  fromType,\n  previewId,\n  mfaCode,\n  ...options\n}: MeshExecuteTransferRequest): Promise<MeshExecuteTransferResponse> {\n  const body = {\n    fromAuthToken,\n    fromType,\n    previewId,\n    ...(mfaCode && { mfaCode }),\n  }\n\n  return sendPostRequest({\n    uri: `${API_BASE_URL}/mesh/transfers/managed/execute`,\n    body,\n    ...options,\n  })\n}\n\nexport async function meshExecuteTransferProxy({\n  apiKey,\n  logger,\n  signal,\n  ...props\n}: MeshExecuteTransferRequestProxy): Promise<MeshExecuteTransferResponse> {\n  const body = { ...props }\n\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/mesh/transfers/managed/execute`,\n    body,\n    apiKey,\n    logger,\n    signal,\n  })\n}\n\ninterface SaveTokensToMeshProxyRequestBody extends BaseApiRequest {\n  deviceId?: string | null\n  brokerType: string\n  accessToken: string\n  refreshToken: string | null\n  accessTokenExpiresIn: number\n  accessTokenExpiresAt: string\n  refreshTokenExpiresAt?: string | null\n}\n\ninterface SaveTokensToMeshProxyResponseBody {\n  id: number\n  createdAt: Date\n  updatedAt: Date\n  deviceId: string\n  integrationId: string\n  accessToken: string\n  accessTokenExpiresAt: Date | null\n  accessTokenExpiresIn: number | null\n  refreshToken: string | null\n  refreshTokenExpiresAt: Date | null\n}\n\nexport async function saveTokensToMeshProxy({\n  apiKey,\n  logger,\n  signal,\n  ...props\n}: SaveTokensToMeshProxyRequestBody): Promise<SaveTokensToMeshProxyResponseBody> {\n  const body = { ...props }\n\n  return sendPostRequest({\n    uri: `${MESH_API_BASE_URL}/api/tokens`,\n    body,\n    apiKey,\n    logger,\n    signal,\n  })\n}\n\ninterface RemoveTokensFromMeshProxyRequestBody extends BaseApiRequest {\n  deviceId: string\n  brokerType: string\n}\n\nexport async function removeTokensFromMeshProxy({\n  deviceId,\n  brokerType,\n  ...options\n}: RemoveTokensFromMeshProxyRequestBody): Promise<void> {\n  return await sendDeleteRequest({\n    uri: `${MESH_API_BASE_URL}/api/tokens?deviceId=${deviceId}&brokerType=${brokerType}`,\n    ...options,\n  })\n}\n", "import type { BaseApiRequest } from '../../consts'\n\nexport interface MeshError {\n  displayMessage?: string | null\n  errorData?: unknown\n  errorType?: string | null\n  message?: string | null\n  status: string\n}\n\nexport interface GetCryptocurrencyHoldingsRequest extends BaseApiRequest {\n  authToken: string\n  type: string\n}\n\nexport interface GetCryptocurrencyHoldingsRequestProxy extends BaseApiRequest {\n  deviceId: string\n  brokerType: string\n}\n\nexport interface GetTransferIntegrationsRequest extends BaseApiRequest {}\n\nexport interface IntegrationNetworkInfo {\n  chainId: string\n  id: string\n  logoUrl: string\n  name: string\n  nativeSymbol: string\n  supportedTokens: string[]\n}\n\nexport interface TransferIntegration {\n  networks: IntegrationNetworkInfo[]\n  supportsIncomingTransfers: boolean\n  supportsOutgoingTransfers: boolean\n  type: string\n}\n\nexport interface GetTransferIntegrationsResponse {\n  integrations: TransferIntegration[]\n}\n\nexport interface GetLinkTokenRequest extends BaseApiRequest {\n  userId: string\n  integrationId?: string | null\n  restrictMultipleAccounts?: boolean\n  transferOptions?: Record<string, unknown> | null\n}\n\nexport interface GetLinkTokenResponse {\n  linkToken: string\n}\n\nexport interface PreviewTransferRequest extends BaseApiRequest {\n  fromAuthToken: string\n  fromType: string\n  toAuthToken?: string | null\n  toType?: string | null\n  networkId?: string\n  symbol?: string | null\n  toAddress?: string | null\n  amount?: string | null\n  amountInFiat?: string | null\n  fiatCurrency?: string | null\n}\n\nexport interface PreviewTransferRequestProxy\n  extends Omit<PreviewTransferRequest, 'fromAuthToken' | 'fromType'> {\n  deviceId: string\n  brokerType: string\n}\n\nexport interface MeshExecuteTransferRequest extends BaseApiRequest {\n  fromAuthToken: string\n  fromType: string\n  previewId: string\n  mfaCode?: string | null\n}\n\nexport interface MeshExecuteTransferRequestProxy\n  extends Omit<MeshExecuteTransferRequest, 'fromAuthToken' | 'fromType'> {\n  deviceId: string\n  brokerType: string\n}\n\n// Reference: https://docs.meshconnect.com/reference/post_api-v1-transfers-managed-execute\nexport enum MeshExecuteTransferStatus {\n  succeeded = 'succeeded',\n  failed = 'failed',\n  mfaRequired = 'mfaRequired',\n  emailConfirmationRequired = 'emailConfirmationRequired',\n  emailConfirmationApprovalRequired = 'emailConfirmationApprovalRequired',\n  deviceConfirmationRequired = 'deviceConfirmationRequired',\n  mfaFailed = 'mfaFailed',\n  addressWhitelistRequired = 'addressWhitelistRequired',\n  secondMfaRequired = 'secondMfaRequired',\n}\n\nexport enum MeshExecuteTransferMfaType {\n  unspecified = 'unspecified',\n  phone = 'phone',\n  email = 'email',\n  totp = 'totp',\n  face = 'face',\n  tradingPin = 'tradingPin',\n  mobile = 'mobile',\n}\n\nexport interface MeshExecuteTransferResponse {\n  status: MeshExecuteTransferStatus\n  mfaType?: MeshExecuteTransferMfaType\n  verificationSteps?: MeshExecuteTransferMfaType[]\n  errorMessage: string | null\n  executeTransferResult: object | null\n}\n\nexport interface MeshCryptoCurrencyPosition {\n  symbol: string\n  amount: number\n}\n\n// the real response is flat, ie. the data we're really interested in are not in a `content` field but directly in the response root, that's why we're omitting the `content` field here and merging it with the root to be flat\nexport interface GetCryptocurrencyHoldingsResponse {\n  cryptocurrencyPositions: MeshCryptoCurrencyPosition[]\n}\n\nexport interface MeshProxyUnauthorizedResponse {\n  error: string\n}\n\n/*\nhttps://docs.meshconnect.com/api-reference/managed-transfers/preview-transfer\n */\nexport interface PreviewTransferResponse {\n  /** The status of the operation. */\n  status: 'succeeded' | 'failed' | 'requiresFunding'\n  /** Error message, if the operation did not complete successfully. */\n  errorMessage: string | null\n  /** Result of the preview. */\n  previewResult: PreviewTransferResult | null\n  transferBalanceFundingAvailability: TransferBalanceFundingAvailability | null\n}\n\nexport interface PreviewTransferResult {\n  previewId: string\n  previewExpiresIn: number\n  fromAddress: string | null\n  toAddress: string | null\n  addressTag: string | null\n  symbol: string | null\n  amount: number\n  amountInFiat: number\n  totalEstimatedAmount: number\n  totalEstimatedAmountInFiat: number\n  networkId: string\n  networkName: string | null\n  contractAddress: string | null\n  institutionTransferFee: TransferFee | null\n  estimatedNetworkGasFee: TransferFee | null\n  decimalPlaces: number | null\n  unitPrice: number\n  clientTransactionId: string | null\n  clientFee: number | null\n  customClientFee: TransferFee | null\n  processingFeeRetainMethod: ProcessingFeeRetainMethod | null\n  transferType: TransferTypeEnum | null\n  isCustomClientFeeProvided: boolean\n  amountWithCustomClientFee: number\n  isFeeIncluded: boolean\n  amountToReceive: number\n  amountToReceiveInFiat: number\n  transferAmountToRequest: number\n}\n\nexport interface TransferFee {\n  fee: number\n  feeCurrency: string | null\n  feeInFiat: number\n}\n\nexport interface ProcessingFeeRetainMethod {\n  type: 'default' | 'smartDeposit'\n  processingFeeAddress: string | null\n}\n\nexport type TransferTypeEnum = 'deposit' | 'payment' | 'onramp'\n\nexport interface TransferBalanceFundingAvailability {\n  status:\n    | 'disabled'\n    | 'available'\n    | 'requiresAmountLowering'\n    | 'notApplicable'\n    | 'unavailable'\n  transferTotalAmount: number\n  unitPrice: number\n  gasFeeBuffer: TransferFee | null\n  symbol: string | null\n  transferTotalAmountInFiat: number\n}\n\n// Reference: https://docs.meshconnect.com/api-reference/managed-transfers/configure-transfer#body-to-addresses\nexport interface MeshConfigureTransferToAddressParams {\n  /**\n   * The address to send the asset to.\n   */\n  address: string\n\n  /**\n   * Secondary address identifier for coins like XRP, XMR, etc.\n   */\n  addressTag?: string | null\n\n  /**\n   * The ID of the network in Front system.\n   */\n  networkId: string\n\n  /**\n   * The symbol of the digital asset.\n   */\n  symbol: string\n}\n\n// Reference: https://docs.meshconnect.com/api-reference/managed-transfers/configure-transfer\nexport interface MeshConfigureTransferParams {\n  /**\n   * The authentication token to send assets from.\n   */\n  fromAuthToken: string\n\n  /**\n   * The type of the integration to send assets from.\n   */\n  fromType: string\n\n  /**\n   * The authentication token of the target integration. Can be used alternatively to the list of requested address ({@link toAddresses}).\n   *\n   * If used, {@link toType} should also be provided.\n   */\n  toAuthToken?: string | null\n\n  /**\n   * The type of the target integration to send assets to. Used along with the {@link toAuthToken} alternatively to {@link toAddresses}.\n   */\n  toType?: string | null\n\n  /**\n   * A list of available addresses provided by the API client. The list can contain all supported addresses by the client.\n   *\n   * Front API validates the addresses and returns the list of supported tokens and networks as the result of the operation.\n   */\n  toAddresses?: MeshConfigureTransferToAddressParams[] | null\n\n  /**\n   * If provided, Front API returns only networks that support transferring of this symbol.\n   */\n  symbol?: string | null\n\n  /**\n   * If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer.\n   */\n  amount?: number | null\n\n  /**\n   * If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer. Can be used alternatively to {@link amount}.\n   */\n  amountInFiat?: number | null\n\n  /**\n   * Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `\"USD\"`.\n   */\n  fiatCurrency?: string | null\n\n  /**\n   * If provided, Front API configures the response to include the requested network only.\n   */\n  networkId?: string | null\n\n  /**\n   * Specifies if all the fees are included in the amount to transfer.\n   */\n  isInclusiveFeeEnabled?: boolean\n}\n\nexport interface MeshConfigureTransferParamsProxy\n  extends Omit<MeshConfigureTransferParams, 'fromAuthToken' | 'fromType'> {\n  deviceId: string\n  brokerType: string\n}\n\nexport interface MeshConfigureTransferResponse {\n  amountInFiat?: number | null\n  fiatCurrency?: string | null\n  holdings?: {\n    availableBalance: number\n    availableBalanceInFiat: number\n    eligibleForTransfer: boolean\n    eligibleForTransferWithFunding: boolean\n    ineligibilityReason?:\n      | 'amountNotSufficient'\n      | 'eligibleWithFunding'\n      | 'noEligibleNetworks'\n      | 'noPrice'\n      | 'notSupportedForTransferBySource'\n      | 'notSupportedForTransferByTarget'\n      | 'symbolDoesNotMatch'\n    logoUrl?: string | null\n    networks: {\n      caipNetworkId?: string | null\n      eligibleForTransfer: boolean\n      eligibleForTransferWithFunding: boolean\n      estimatedNetworkGasFee?: {\n        fee: number\n        feeCurrency?: string | null\n        feeInFiat: number\n      }\n      id: string\n      ineligibilityReason?:\n        | 'amountNotSufficient'\n        | 'balanceBelowMinimum'\n        | 'balanceBelowRequestedAmount'\n        | 'eligibleWithFunding'\n        | 'gasFeeAssetBalanceNotEnough'\n        | 'noPrice'\n        | 'nyCoinbaseUserRestrictions'\n        | 'refusedByInstitution'\n        | 'requestedAmountAboveClientMaximum'\n        | 'requestedAmountBelowFees'\n        | 'requestedAmountBelowClientMinimum'\n        | 'requestedAmountBelowMinimum'\n      institutionTransferFee?: {\n        fee: number\n        feeCurrency?: string | null\n        feeInFiat: number\n      }\n      logoUrl?: string | null\n      maximumAmount?: number | null\n      maximumAmountInFiat?: number | null\n      minimumAmount?: number | null\n      minimumAmountInFiat?: number | null\n      minimumRequiredForTransferAmount?: number | null\n      name?: string | null\n      totalEstimatedTransferFeeInFiat?: number | null\n      toAddress?: string | null\n      transferAmount?: number | null\n    }[]\n    symbol?: string | null\n  }[]\n  maximumTransferAmountInFiat?: number | null\n  minimumTransferAmountInFiat?: number | null\n  status: MeshConfigureTransferStatus\n  supportedFiatCurrencies?: string[] | null\n  transferBalanceFundingAvailability?: {\n    status:\n      | 'available'\n      | 'disabled'\n      | 'notApplicable'\n      | 'requiresAmountLowering'\n      | 'unavailable'\n  }\n}\n\n// Reference: https://docs.meshconnect.com/api-reference/managed-transfers/configure-transfer#response-content-status\nexport enum MeshConfigureTransferStatus {\n  failed = 'failed',\n  fromIntegrationNotSupported = 'fromIntegrationNotSupported',\n  kycRequired = 'kycRequired',\n  notAuthorizedFrom = 'notAuthorizedFrom',\n  notAuthorizedTo = 'notAuthorizedTo',\n  succeeded = 'succeeded',\n  toIntegrationNotSupported = 'toIntegrationNotSupported',\n  validationFailed = 'validationFailed',\n}\n", "import { ErrorCode, InternalFailureError } from '@funkit/utils'\nimport { API_BASE_URL } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  GetMoonpayBuyQuoteForCreditCardRequest,\n  GetMoonpayBuyQuoteForCreditCardResponse,\n  GetMoonpayUrlSignatureRequest,\n} from './types'\n\ninterface GetMoonpayUrlSignatureResponse {\n  url: string\n}\n\nexport async function getMoonpayUrlSignature({\n  url,\n  isSandbox,\n  ...options\n}: GetMoonpayUrlSignatureRequest): Promise<string> {\n  const signature = await sendPostRequest<GetMoonpayUrlSignatureResponse>({\n    uri: `${API_BASE_URL}/on-ramp/moonpay-signature/`,\n    body: { url, isSandbox },\n    ...options,\n  })\n  if (!signature || !signature?.url) {\n    throw new InternalFailureError(\n      ErrorCode.UnknownServerError,\n      'No onramp url found.',\n      '',\n      { url },\n      'This is an internal error, please contact support.',\n      'https://docs.fun.xyz',\n    )\n  }\n  return signature.url\n}\n\nexport async function getMoonpayBuyQuoteForCreditCard({\n  currencyCode,\n  baseCurrencyCode,\n  quoteCurrencyAmount,\n  baseCurrencyAmount,\n  extraFeePercentage,\n  areFeesIncluded,\n  ...options\n}: GetMoonpayBuyQuoteForCreditCardRequest): Promise<GetMoonpayBuyQuoteForCreditCardResponse> {\n  const params = new URLSearchParams({\n    currencyCode,\n    baseCurrencyCode,\n    quoteCurrencyAmount,\n    paymentMethod: 'credit_debit_card',\n    ...(baseCurrencyAmount == null\n      ? {}\n      : { baseCurrencyAmount: baseCurrencyAmount.toString() }),\n    ...(extraFeePercentage == null\n      ? {}\n      : { extraFeePercentage: extraFeePercentage.toString() }),\n    ...(areFeesIncluded == null\n      ? {}\n      : { areFeesIncluded: areFeesIncluded.toString() }),\n  }).toString()\n\n  return sendGetRequest({\n    uri: `${API_BASE_URL}/on-ramp/moonpay-buy-quote?${params}`,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendGetRequest } from '../../utils'\nimport type { GetOrganizationIdRequest } from './types'\n\nexport async function getOrganizationIdByApiKey({\n  apiKey,\n}: GetOrganizationIdRequest) {\n  return await sendGetRequest<{ id: string }>({\n    uri: `${API_BASE_URL}/organization`,\n    apiKey,\n  })\n}\n", "import { API_BASE_URL, type BaseApiRequest } from '../../consts'\nimport { sendGetRequest, sendPostRequest } from '../../utils'\nimport type {\n  CreateStripeBuySessionBody,\n  CreateStripeBuySessionResponse,\n  GetStripeBuyQuoteRequest,\n  GetStripeBuyQuoteResponse,\n} from './types'\n\nexport async function getStripeBuyQuote({\n  sourceCurrency,\n  destinationAmount,\n  destinationCurrency,\n  destinationNetwork,\n  isSandbox,\n  ...options\n}: GetStripeBuyQuoteRequest): Promise<GetStripeBuyQuoteResponse> {\n  const params = new URLSearchParams({\n    isSandbox: isSandbox.toString(),\n    sourceCurrency,\n    destinationAmount: destinationAmount.toString(),\n    // Only allow one currency in this SDK\n    destinationCurrencies: destinationCurrency,\n    // Only allow one network in this SDK\n    destinationNetworks: destinationNetwork,\n  }).toString()\n  const buyQuoteResp = await sendGetRequest({\n    uri: `${API_BASE_URL}/on-ramp/stripe-buy-quote?${params}`,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n  return buyQuoteResp as GetStripeBuyQuoteResponse\n}\n\nexport async function createStripeBuySession({\n  sourceCurrency,\n  destinationAmount,\n  destinationCurrency,\n  destinationNetwork,\n  walletAddress,\n  customerIpAddress,\n  isSandbox,\n  ...options\n}: CreateStripeBuySessionBody): Promise<CreateStripeBuySessionResponse> {\n  const body = {\n    isSandbox: isSandbox.toString(),\n    sourceCurrency,\n    destinationAmount: destinationAmount.toString(),\n    // Only allow one currency in this SDK\n    destinationCurrency,\n    destinationCurrencies: [destinationCurrency],\n    // Only allow one network in this SDK\n    destinationNetwork,\n    destinationNetworks: [destinationNetwork],\n    // Only allow one wallet address in this SDK, and it must correspond to the destination network\n    walletAddresses: {\n      [destinationNetwork]: walletAddress,\n    },\n    ...(customerIpAddress ? { customerIpAddress } : {}),\n  }\n  const newBuySessionResp = await sendPostRequest({\n    uri: `${API_BASE_URL}/on-ramp/stripe-checkout`,\n    body,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n  return newBuySessionResp as CreateStripeBuySessionResponse\n}\n\nexport async function getStripeBuySession({\n  sessionId,\n  ...options\n}: BaseApiRequest & {\n  sessionId: string\n}): Promise<CreateStripeBuySessionResponse> {\n  const buySessionResp = await sendGetRequest({\n    uri: `${API_BASE_URL}/on-ramp/stripe-checkout-session/${sessionId}`,\n    retryOptions: { maxAttempts: 1 },\n    ...options,\n  })\n  return buySessionResp as CreateStripeBuySessionResponse\n}\n", "import { API_BASE_URL } from '../../consts'\nimport { sendPostRequest } from '../../utils'\nimport type { SendSupportMessageRequest } from './types'\n\nexport async function sendSupportMessage({\n  title,\n  description,\n  userEmail,\n  ...options\n}: SendSupportMessageRequest): Promise<boolean> {\n  try {\n    await sendPostRequest({\n      uri: `${API_BASE_URL}/support/send-message`,\n      body: { title, description, userEmail },\n      retryOptions: { maxAttempts: 1 },\n      ...options,\n    })\n    return true\n  } catch (_err) {\n    return false\n  }\n}\n"],
  "mappings": "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",
  "names": ["InvalidParameterError", "ResourceNotFoundError", "UserOpFailureError", "BridgeCustomerStatus", "BridgeKycStatus", "BridgeTosStatus", "BridgeCustomerType", "BridgeEndorsement", "BridgeVirtualBankAccountStatus", "ErrorCode", "ResourceNotFoundError", "CheckoutState", "CheckoutRefundState", "ResourceNotFoundError", "ErrorCode", "DirectExecutionType", "RelayExecutionStatus", "OperationStatus", "AuthType", "OperationType", "PaymasterType", "ResourceNotFoundError", "InvalidParameterError", "ResourceNotFoundError", "InvalidParameterError", "MeldServiceProvider", "MeshExecuteTransferStatus", "MeshExecuteTransferMfaType", "MeshConfigureTransferStatus", "ErrorCode", "InternalFailureError", "InternalFailureError", "ErrorCode"]
}
