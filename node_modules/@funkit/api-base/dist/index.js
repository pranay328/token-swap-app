// src/consts/api.ts
var API_BASE_URL = "https://api.fun.xyz/v1";
var MESH_API_BASE_URL = "https://frog.fun.xyz";
var FUN_FAUCET_URL = "https://api.fun.xyz/demo-faucet";

// src/utils/error.ts
import {
  InvalidParameterError,
  ResourceNotFoundError,
  UserOpFailureError
} from "@funkit/utils";
var errorAbortHandler = (err, context) => {
  if (err instanceof ResourceNotFoundError || err instanceof InvalidParameterError || err instanceof UserOpFailureError) {
    context.abort();
  }
};

// src/consts/retry.ts
var DEFAULT_RETRY_OPTIONS = {
  delay: 100,
  initialDelay: 0,
  maxDelay: 3e3,
  factor: 2,
  maxAttempts: 5,
  timeout: 0,
  jitter: true,
  minDelay: 0,
  handleError: errorAbortHandler,
  handleTimeout: null,
  beforeAttempt: null,
  calculateDelay: null
};

// src/consts/customers.ts
var DEGEN_API_KEY = "m4iHIILHcL4gN8EXCMzGe8zIdhuCXxck49mWajzJ";
var DYDX_API_KEY = "NJq0CGrsE19xBbP1vHyBOp8xJvzYo9kayJHqDFP5";
var POLYMARKET_API_KEY = "Y53dikxXdT4E3afI1l8BMBSWgyhKvf65k6Dut1k6";
var OSTIUM_API_KEY = "SMbBD7DS9b3EPcyBVg4a8az1rRWR9xB068chHoUN";
var DEV_API_KEY = "Z9SZaOwpmE40KX61mUKWm5hrpGh7WHVkaTvQJpQk";
var BANKR_API_KEY = "vWe20Dfyui2ouvfOhtSTY3Czeo8lFdbo5xXQBALZ";
var QUICKSWAP_API_KEY = "sdbYyJRkXz7uuCCiA7KDu2SzYknwgwCN5rgBllKR";
var BSX_API_KEY = "zN1zrkmLQn4oZtLUW9Qt02uuBI3Jvrgj8Ni40Gf1";
var BENQI_API_KEY = "q8qZWLvviLaOaG4bX3w2v6zLN9uxNPaU6CX8I0Gd";
var ETHEREAL_API_KEY = "M3uox3cw0u8YCPV9cIREA6AugUMvPFTk6qOpm4um";
var KATANA_API_KEY = "OXLUmejkh9PlNDS4gSvi9gcEWacOpTz2KUVepVf4";
var ETHERFI_API_KEY = "GyJMyQ3juDarKooebGRu16Ncogwhm59h2DIjCu1p";
var SUSHI_API_KEY = "HKHvPSPDezaxsTohFgDuG4WpKW6hB4SFYyztm9vc";
var FELIX_API_KEY = "Z9SZaOwpmE40KX61mUKWm5hrpGh7WHVkaTvQJpQk";

// src/utils/checkout.ts
import { toHex } from "viem";
function randomBytes(length) {
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; i++) {
    bytes[i] = Math.floor(Math.random() * 256);
  }
  return toHex(bytes);
}
function generateRandomCheckoutSalt() {
  return toHex(BigInt(randomBytes(32)));
}
function roundToNearestBottomTenth(n) {
  return Math.floor(n / 10) * 10;
}

// src/utils/request.ts
import { retry } from "@lifeomic/attempt";
import {
  AccessDeniedError,
  ErrorCode,
  InternalFailureError,
  InvalidParameterError as InvalidParameterError2,
  ResourceNotFoundError as ResourceNotFoundError2,
  ThrottlingError,
  UserOpFailureError as UserOpFailureError2,
  jsonStringifyWithBigIntSanitization
} from "@funkit/utils";
async function sendRequest({
  uri,
  method,
  apiKey,
  body = {},
  logger,
  retryOptions = {},
  signal
}) {
  const headers = {
    "Content-Type": "application/json",
    ...apiKey ? { "X-Api-Key": apiKey } : {}
  };
  try {
    const finalRetryOptions = {
      ...DEFAULT_RETRY_OPTIONS,
      ...retryOptions
    };
    return retry(async (context) => {
      const startTimeMs = Date.now();
      const fetchParams = {
        method,
        headers,
        redirect: "follow",
        signal,
        body: method !== "GET" ? jsonStringifyWithBigIntSanitization(body) : void 0
      };
      logger?.info("api-base:sendRequest_before", {
        uri,
        fetchParams,
        startTimeMs
      });
      const response = await fetch(uri, fetchParams);
      const json = await response.json();
      const endTimeMs = Date.now();
      logger?.info("api-base:sendRequest_after", {
        url: uri,
        fetchParams,
        endTimeMs,
        response: {
          body: json,
          status: response.status
        },
        durationMs: endTimeMs - startTimeMs,
        retries: context.attemptNum
      });
      if (response.ok) {
        return json;
      }
      const { errorMsg, errorCode } = json;
      if (response.status === 400) {
        throw new InvalidParameterError2(
          ErrorCode.InvalidParameter,
          `bad request ${JSON.stringify(json)}`,
          errorMsg,
          { body },
          "check the api call parameters. its mostly because some call parameters are wrong",
          "https://docs.fun.xyz"
        );
      }
      if (response.status === 403) {
        throw new AccessDeniedError(
          ErrorCode.Unauthorized,
          "Invalid API key or insufficient access.",
          errorMsg,
          { apiKey },
          "Check your api key at https://app.fun.xyz and check with fun team if you believe something is off",
          "https://docs.fun.xyz"
        );
      }
      if (response.status === 404) {
        throw new ResourceNotFoundError2(
          ErrorCode.ServerMissingData,
          JSON.stringify(json),
          errorMsg,
          { body },
          "check the api call parameters. its mostly because some call parameters are wrong",
          "https://docs.fun.xyz"
        );
      }
      if (response.status === 429) {
        throw new ThrottlingError(
          ErrorCode.RequestLimitExceeded,
          `too many requests ${JSON.stringify(json)}`,
          "Too many requests",
          { body },
          "you are making too many requests. please slow down. Reach out to fun team if you need more quota",
          "https://docs.fun.xyz"
        );
      }
      if (response.status === 500) {
        if (errorCode === ErrorCode.UserOpFailureError) {
          throw new UserOpFailureError2(
            ErrorCode.UserOpFailureError,
            JSON.stringify(json),
            // UserOpFailureError may JSON.parse this! Do not modify!
            errorMsg,
            { body },
            "fix user op failure. Most of the time this is due to invalid parameters",
            "https://docs.fun.xyz"
          );
        }
        throw new InternalFailureError(
          ErrorCode.ServerFailure,
          `server failure ${JSON.stringify(json)}`,
          errorMsg,
          { body },
          "retry later. if it still fails, please contact us.",
          "https://docs.fun.xyz"
        );
      }
      if (response.status === 504) {
        throw new InternalFailureError(
          ErrorCode.ServerTimeout,
          `server timeout failure ${JSON.stringify(json)}`,
          errorMsg,
          { body },
          "retry later. if it still fails, please contact us.",
          "https://docs.fun.xyz"
        );
      }
      if (!response.ok) {
        throw new InternalFailureError(
          ErrorCode.UnknownServerError,
          `unknown server failure ${JSON.stringify(json)}`,
          errorMsg,
          { body },
          "retry later. if it still fails, please contact us.",
          "https://docs.fun.xyz"
        );
      }
      return {};
    }, finalRetryOptions);
  } catch (err) {
    logger?.error("api-base:fetch_error", {
      url: uri,
      method,
      request: {
        body,
        headers
      },
      error: err
    });
    throw new InternalFailureError(
      ErrorCode.ServerConnectionError,
      `Cannot connect to Fun API Service ${err}`,
      "",
      { body },
      "retry later. if it still fails, please contact us.",
      "https://docs.fun.xyz"
    );
  }
}
async function sendGetRequest(options) {
  return await sendRequest({ ...options, method: "GET" });
}
async function sendPostRequest(options) {
  return await sendRequest({ ...options, method: "POST" });
}
async function sendPutRequest(options) {
  return await sendRequest({ ...options, method: "PUT" });
}
async function sendDeleteRequest(options) {
  await sendRequest({ ...options, method: "DELETE" });
}

// src/services/assets/endpoints.ts
async function getAssetPriceInfo({
  chainId,
  assetTokenAddress,
  ...options
}) {
  const priceInfo = await sendGetRequest({
    uri: `${API_BASE_URL}/asset/erc20/price/${chainId}/${assetTokenAddress}`,
    retryOptions: { maxAttempts: 2 },
    ...options
  });
  return priceInfo;
}
async function getAssetErc20ByChainAndSymbol({
  chainId,
  symbol,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/asset/erc20/${chainId}/${symbol}`,
    retryOptions: { maxAttempts: 2 },
    ...options
  });
}
async function getAllWalletTokens({
  walletAddress,
  onlyVerifiedTokens,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/assets/erc20s/${walletAddress}?onlyVerifiedTokens=${onlyVerifiedTokens}`,
    retryOptions: { maxAttempts: 2 },
    ...options
  });
}
async function getAllWalletTokensByChainId({
  chainId,
  walletAddress,
  onlyVerifiedTokens,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/assets/erc20s/${walletAddress}/${chainId}?onlyVerifiedTokens=${onlyVerifiedTokens}`,
    retryOptions: { maxAttempts: 2 },
    ...options
  });
}
async function getAllowedAssets(options) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/assets/allow`,
    retryOptions: { maxAttempts: 2 },
    ...options
  });
}
async function getAllWalletNFTs({
  walletAddress,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/assets/nfts/${walletAddress}`,
    ...options
  });
}
async function getAllWalletNFTsByChainId({
  chainId,
  walletAddress,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/assets/nfts/${walletAddress}/${chainId}`,
    ...options
  });
}
async function getWalletLidoWithdrawalsByChainId({
  chainId,
  walletAddress,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/assets/lido-withdrawals/${walletAddress}/${chainId}`,
    ...options
  });
}
async function getNftName({
  chainId,
  nftAddress,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/asset/nft/${chainId}/${nftAddress}`,
    ...options
  });
}
async function getNftAddress({
  name,
  ...options
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/asset/nft?name=${name}`,
    ...options
  });
}

// src/services/bridge/endpoints.ts
async function getFrogAccount({
  subAccountId,
  subAccountType,
  ...options
}) {
  const search = new URLSearchParams({
    subAccountId,
    subAccountType
  });
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/account?${search}`,
    ...options
  });
}
async function createFrogAccount({
  subAccountId,
  subAccountType,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/api/account`,
    body: {
      subAccountId,
      subAccountType
    },
    ...options
  });
}
async function getBridgeCustomer({
  guid,
  ...options
}) {
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/bridge?guid=${guid}`,
    ...options
  });
}
async function createBridgeCustomer({
  guid,
  name,
  email,
  endorsement,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/api/bridge`,
    body: {
      guid,
      name,
      email,
      endorsement
    },
    ...options
  });
}
async function getBridgeBankAccounts({
  subAccountId,
  ...options
}) {
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/bridge/bank?subAccountId=${subAccountId}`,
    ...options
  });
}
async function createBridgeBankAccount({
  tokenName,
  chainName,
  destinationAddress,
  subAccountId,
  sourceCurrency,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/api/bridge/bank`,
    body: {
      subAccountId,
      tokenName,
      chainName,
      destinationAddress,
      sourceCurrency
    },
    ...options
  });
}
function getBridgeKycLink({
  guid,
  ...options
}) {
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/bridge/kyclink?guid=${guid}`,
    ...options
  });
}

// src/services/bridge/types.ts
var BridgeCustomerStatus = /* @__PURE__ */ ((BridgeCustomerStatus2) => {
  BridgeCustomerStatus2["ACTIVE"] = "active";
  BridgeCustomerStatus2["AWAITING_QUESTIONNAIRE"] = "awaiting_questionnaire";
  BridgeCustomerStatus2["AWAITING_UBO"] = "awaiting_ubo";
  BridgeCustomerStatus2["INCOMPLETE"] = "incomplete";
  BridgeCustomerStatus2["NOT_STARTED"] = "not_started";
  BridgeCustomerStatus2["OFFBOARDED"] = "offboarded";
  BridgeCustomerStatus2["PAUSED"] = "paused";
  BridgeCustomerStatus2["REJECTED"] = "rejected";
  BridgeCustomerStatus2["UNDER_REVIEW"] = "under_review";
  return BridgeCustomerStatus2;
})(BridgeCustomerStatus || {});
var BridgeKycStatus = /* @__PURE__ */ ((BridgeKycStatus2) => {
  BridgeKycStatus2["APPROVED"] = "approved";
  BridgeKycStatus2["INCOMPLETE"] = "incomplete";
  BridgeKycStatus2["NOT_STARTED"] = "not_started";
  BridgeKycStatus2["REJECTED"] = "rejected";
  BridgeKycStatus2["UNDER_REVIEW"] = "under_review";
  return BridgeKycStatus2;
})(BridgeKycStatus || {});
var BridgeTosStatus = /* @__PURE__ */ ((BridgeTosStatus2) => {
  BridgeTosStatus2["APPROVED"] = "approved";
  BridgeTosStatus2["PENDING"] = "pending";
  return BridgeTosStatus2;
})(BridgeTosStatus || {});
var BridgeCustomerType = /* @__PURE__ */ ((BridgeCustomerType2) => {
  BridgeCustomerType2["BUSINESS"] = "business";
  BridgeCustomerType2["INDIVIDUAL"] = "individual";
  return BridgeCustomerType2;
})(BridgeCustomerType || {});
var BridgeEndorsement = /* @__PURE__ */ ((BridgeEndorsement2) => {
  BridgeEndorsement2["BASE"] = "base";
  BridgeEndorsement2["SEPA"] = "sepa";
  return BridgeEndorsement2;
})(BridgeEndorsement || {});
var BridgeVirtualBankAccountStatus = /* @__PURE__ */ ((BridgeVirtualBankAccountStatus2) => {
  BridgeVirtualBankAccountStatus2["ACTIVATED"] = "activated";
  BridgeVirtualBankAccountStatus2["DEACTIVATED"] = "deactivated";
  return BridgeVirtualBankAccountStatus2;
})(BridgeVirtualBankAccountStatus || {});

// src/services/checkout/endpoints.ts
import Big from "big.js";
import { ErrorCode as ErrorCode2, ResourceNotFoundError as ResourceNotFoundError3 } from "@funkit/utils";

// src/services/checkout/types.ts
var CheckoutState = /* @__PURE__ */ ((CheckoutState2) => {
  CheckoutState2["FROM_UNFUNDED"] = "FROM_UNFUNDED";
  CheckoutState2["FROM_FUNDED"] = "FROM_FUNDED";
  CheckoutState2["FROM_POOLED"] = "FROM_POOLED";
  CheckoutState2["TO_UNFUNDED"] = "TO_UNFUNDED";
  CheckoutState2["TO_FUNDED"] = "TO_FUNDED";
  CheckoutState2["TO_POOLED"] = "TO_POOLED";
  CheckoutState2["TO_READY"] = "TO_READY";
  CheckoutState2["PENDING_RECEIVAL"] = "PENDING_RECEIVAL";
  CheckoutState2["COMPLETED"] = "COMPLETED";
  CheckoutState2["CHECKOUT_ERROR"] = "CHECKOUT_ERROR";
  CheckoutState2["EXPIRED"] = "EXPIRED";
  CheckoutState2["CANCELLED"] = "CANCELLED";
  return CheckoutState2;
})(CheckoutState || {});
var FROM_PROGRESS_CHECKOUT_STATES = [
  "FROM_UNFUNDED" /* FROM_UNFUNDED */,
  "FROM_FUNDED" /* FROM_FUNDED */,
  "FROM_POOLED" /* FROM_POOLED */
];
var TO_PROGRESS_CHECKOUT_STATES = [
  "TO_UNFUNDED" /* TO_UNFUNDED */,
  "TO_FUNDED" /* TO_FUNDED */,
  "TO_POOLED" /* TO_POOLED */,
  "TO_READY" /* TO_READY */,
  "PENDING_RECEIVAL" /* PENDING_RECEIVAL */
];
var IN_PROGRESS_CHECKOUT_STATES = [
  ...TO_PROGRESS_CHECKOUT_STATES,
  ...FROM_PROGRESS_CHECKOUT_STATES
];
var TERMINAL_CHECKOUT_STATES = [
  "EXPIRED" /* EXPIRED */,
  "CHECKOUT_ERROR" /* CHECKOUT_ERROR */,
  "COMPLETED" /* COMPLETED */,
  "CANCELLED" /* CANCELLED */
];
var CheckoutRefundState = /* @__PURE__ */ ((CheckoutRefundState2) => {
  CheckoutRefundState2["INITIATED"] = "INITIATED";
  CheckoutRefundState2["ERROR"] = "ERROR";
  CheckoutRefundState2["REFUNDED"] = "REFUNDED";
  CheckoutRefundState2["PROCEEDED"] = "PROCEEDED";
  CheckoutRefundState2["WAITING_FOR_FULFILLMENT"] = "WAITING_FOR_FULFILLMENT";
  CheckoutRefundState2["FULFILLED"] = "FULFILLED";
  return CheckoutRefundState2;
})(CheckoutRefundState || {});

// src/services/checkout/endpoints.ts
var DEFAULT_EXPIRATION_TIMESTAMP_MS = 15 * 60 * 1e3;
async function getCheckoutQuote({
  fromChainId,
  fromTokenAddress,
  fromTokenDecimals,
  toChainId,
  toTokenAddress,
  toTokenDecimals,
  toTokenAmount,
  sponsorInitialTransferGasLimit,
  recipientAddr,
  userId,
  ...options
}) {
  try {
    const toMultipler = 10 ** toTokenDecimals;
    const toAmountBaseUnitBI = BigInt(Math.floor(toTokenAmount * toMultipler));
    const queryParams = {
      userId,
      fromChainId,
      fromTokenAddress,
      toChainId,
      toTokenAddress,
      toAmountBaseUnit: toAmountBaseUnitBI.toString(),
      // Only pass in recipientAddr if specified
      ...recipientAddr ? { recipientAddr } : {},
      // Rounding nearest tenth second (instead of seconds) to better support backend quote caching feature
      // Reference: https://vintage-heaven-3cd.notion.site/API-Gateway-Caching-and-Pre-Warming-System-Draft-ee7909d9b85f43c793ce7bd2607bec02?pvs=4
      // Note: Rounding *down* instead of a regular round to safeguard against edge case of timing passing frontend range validation but failing backend range validation
      checkoutExpirationTimestampSeconds: roundToNearestBottomTenth(
        Math.round((Date.now() + DEFAULT_EXPIRATION_TIMESTAMP_MS) / 1e3)
      ).toString(),
      sponsorInitialTransferGasLimit
    };
    const searchParams = new URLSearchParams(queryParams);
    const quoteRes = await sendGetRequest({
      uri: `${API_BASE_URL}/checkout/quote?${searchParams}`,
      ...options
    });
    const fromMultipler = 10 ** fromTokenDecimals;
    return {
      quoteId: quoteRes.quoteId,
      fromTokenAddress: quoteRes.fromTokenAddress,
      estFeesUsd: quoteRes.estFeesUsd,
      estSubtotalUsd: quoteRes.estSubtotalUsd,
      estTotalUsd: quoteRes.estTotalUsd,
      estCheckoutTimeMs: quoteRes.estCheckoutTimeMs,
      estTotalFromAmountBaseUnit: quoteRes.estTotalFromAmountBaseUnit,
      estSubtotalFromAmountBaseUnit: quoteRes.estSubtotalFromAmountBaseUnit,
      estFeesFromAmountBaseUnit: quoteRes.estFeesFromAmountBaseUnit,
      estMarketMakerGasUsd: quoteRes.estMarketMakerGasUsd,
      lpFeePercentage: quoteRes.lpFeePercentage,
      lpFeeUsd: quoteRes.lpFeeUsd,
      // Added fields
      estFeesFromAmount: new Big(quoteRes.estFeesFromAmountBaseUnit).div(fromMultipler).toString(),
      estSubtotalFromAmount: new Big(quoteRes.estSubtotalFromAmountBaseUnit).div(fromMultipler).toString(),
      estTotalFromAmount: new Big(quoteRes.estTotalFromAmountBaseUnit).div(fromMultipler).toString()
    };
  } catch (err) {
    throw new Error(
      `An error occurred trying to generate a checkout quote: ${err instanceof Error ? err.message : JSON.stringify(err)}`
    );
  }
}
async function initializeCheckout({
  userOp,
  quoteId,
  sourceOfFund,
  clientMetadata,
  ...options
}) {
  const body = {
    ...userOp ? { userOp } : {},
    quoteId,
    sourceOfFund,
    salt: generateRandomCheckoutSalt(),
    clientMetadata
  };
  const res = await sendPostRequest({
    uri: `${API_BASE_URL}/checkout`,
    body,
    ...options
  });
  if (!res?.depositAddr) {
    throw new ResourceNotFoundError3(
      ErrorCode2.CheckoutInitDepositAddrNotFound,
      "Unable to initialize checkout",
      "Unable to initialize checkout",
      body,
      "",
      "https://docs.fun.xyz"
    );
  }
  return { depositAddr: res.depositAddr };
}
async function deactivateCheckout({
  depositAddress,
  ...options
}) {
  try {
    await sendPostRequest({
      uri: `${API_BASE_URL}/checkout/update/${depositAddress}`,
      body: {
        // Fixed state to cancel the checkout
        state: "CANCELLED" /* CANCELLED */
      },
      ...options
    });
    return true;
  } catch (_err) {
    throw new Error("Unable to deactivate checkout");
  }
}
async function getCheckoutByDepositAddress({
  depositAddress,
  ...options
}) {
  try {
    return await sendGetRequest({
      uri: `${API_BASE_URL}/checkout/${depositAddress}`,
      ...options
    });
  } catch (err) {
    if (err instanceof ResourceNotFoundError3) {
      return null;
    }
    throw err;
  }
}
async function getCheckoutsByFunWalletAddress({
  funWalletAddress,
  ...options
}) {
  const res = await sendGetRequest({
    uri: `${API_BASE_URL}/checkout/fun-wallet/${funWalletAddress}`,
    ...options
  });
  return res || [];
}
async function getCheckoutsByRecipientAddress({
  recipientAddress,
  ...options
}) {
  const res = await sendGetRequest({
    uri: `${API_BASE_URL}/checkout/recipient/${recipientAddress}`,
    ...options
  });
  return res || [];
}
async function getCheckoutsByUserId({
  userId,
  limit,
  ...options
}) {
  const query = limit ? new URLSearchParams({
    limit: limit.toString()
  }) : "";
  const res = await sendGetRequest({
    uri: `${API_BASE_URL}/checkout/userId/${userId}?${query}`,
    ...options
  });
  return res || [];
}
async function getPaymasterDataForCheckoutSponsoredTransfer({
  depositAddress,
  transferUserOp,
  ...options
}) {
  const body = {
    depositAddress,
    userOp: transferUserOp
  };
  const res = await sendPostRequest({
    uri: `${API_BASE_URL}/checkout/sponsor-transfer`,
    body,
    ...options
  });
  if (!res) {
    throw new Error("Unable to get sponsorship information");
  }
  return res;
}
async function getRiskAssessmentForAddress({
  address,
  ...options
}) {
  const response = await sendGetRequest({
    uri: `${API_BASE_URL}/checkout/risk-assessment?address=${address}`,
    ...options,
    // Protect us against chainalysis ratelimiting
    retryOptions: { maxAttempts: 2 }
  });
  return response;
}
async function initializeCheckoutTokenTransferAddress({
  apiKey,
  logger,
  signal,
  ...body
}) {
  const res = await sendPostRequest({
    uri: `${API_BASE_URL}/eoa`,
    body,
    apiKey,
    logger,
    signal
  });
  if (!res?.depositAddr) {
    throw new ResourceNotFoundError3(
      ErrorCode2.CheckoutInitDepositAddrNotFound,
      "Unable to initialize checkout token transfer address",
      "Unable to initialize checkout token transfer address",
      body,
      "",
      "https://docs.fun.xyz"
    );
  }
  return {
    depositAddr: res.depositAddr,
    solanaAddr: res.solanaAddr
  };
}

// src/services/direct-execution/endpoints.ts
async function getDirectExecutionByTxHash({
  txHash,
  apiKey,
  logger,
  signal
}) {
  return sendGetRequest({
    uri: `${API_BASE_URL}/direct-execution/${txHash}`,
    apiKey,
    logger,
    signal
  });
}
async function getDirectExecutionsByUserId({
  userId,
  apiKey,
  logger,
  limit,
  signal
}) {
  const query = limit ? new URLSearchParams({
    limit: limit.toString()
  }) : "";
  return sendGetRequest({
    uri: `${API_BASE_URL}/direct-execution/userId/${userId}?${query}`,
    apiKey,
    logger,
    signal
  });
}
async function createDirectExecution({
  txHash,
  userId,
  recipientAddr,
  fromChainId,
  fromTokenAddress,
  toChainId,
  toTokenAddress,
  fromAmountBaseUnit,
  toAmountBaseUnit,
  estTotalUsd,
  sourceOfFund,
  clientMetadata,
  apiKey,
  logger,
  signal,
  type
}) {
  const body = {
    txHash,
    sourceOfFund,
    userId,
    recipientAddr,
    fromChainId,
    fromTokenAddress,
    toChainId,
    toTokenAddress,
    fromAmountBaseUnit,
    toAmountBaseUnit,
    estTotalUsd,
    clientMetadata,
    type
  };
  return sendPostRequest({
    uri: `${API_BASE_URL}/direct-execution`,
    body,
    apiKey,
    logger,
    signal
  });
}

// src/services/direct-execution/types.ts
var DirectExecutionType = /* @__PURE__ */ ((DirectExecutionType2) => {
  DirectExecutionType2["TEST_EXECUTION"] = "TEST_EXECUTION";
  DirectExecutionType2["VERTEX_DEPOSIT_COLLATERAL_WITH_REFERRAL"] = "VERTEX_DEPOSIT_COLLATERAL_WITH_REFERRAL";
  DirectExecutionType2["RELAY"] = "RELAY";
  return DirectExecutionType2;
})(DirectExecutionType || {});
var RelayExecutionStatus = /* @__PURE__ */ ((RelayExecutionStatus2) => {
  RelayExecutionStatus2["DELAYED"] = "delayed";
  RelayExecutionStatus2["FAILURE"] = "failure";
  RelayExecutionStatus2["PENDING"] = "pending";
  RelayExecutionStatus2["REFUND"] = "refund";
  RelayExecutionStatus2["SUCCESS"] = "success";
  RelayExecutionStatus2["WAITING"] = "waiting";
  RelayExecutionStatus2["UNKNOWN"] = "unknown";
  return RelayExecutionStatus2;
})(RelayExecutionStatus || {});

// src/services/faucet/endpoints.ts
async function getAssetFromFaucet({
  token,
  chain,
  walletAddress,
  ...options
}) {
  return await sendGetRequest({
    uri: `${FUN_FAUCET_URL}/get-faucet?token=${token}&testnet=${chain}&addr=${walletAddress}`,
    ...options
  });
}

// src/services/fw-access/endpoints.ts
async function initializeWalletAccess({
  walletAddr,
  creatorAddr,
  ...options
}) {
  await sendPostRequest({
    uri: `${API_BASE_URL}/access/wallet`,
    body: { walletAddr, creatorAddr },
    ...options
  });
}
async function checkWalletAccessInitialization({
  walletAddr,
  ...options
}) {
  return (await sendGetRequest({
    uri: `${API_BASE_URL}/access/wallet/${walletAddr}`,
    ...options
  })).initialized;
}

// src/services/fw-group/endpoints.ts
async function getGroups({
  groupIds,
  chainId,
  ...options
}) {
  return (await sendPostRequest({
    uri: `${API_BASE_URL}/group/get-groups`,
    body: { groupIds, chainId },
    ...options
  })).groups;
}

// src/services/fw-info/endpoints.ts
async function getChainFromId({
  chainId,
  ...options
}) {
  const res = await sendGetRequest({
    uri: `${API_BASE_URL}/chain-info/${chainId}`,
    ...options
  });
  if (!res) {
    throw new Error(JSON.stringify(res));
  }
  return res;
}
async function getChainFromName({
  name,
  ...options
}) {
  const res = await sendGetRequest({
    uri: `${API_BASE_URL}/chain-info?name=${name}`,
    ...options
  });
  if (!res) {
    throw new Error(JSON.stringify(res));
  }
  return res;
}

// src/services/fw-operation/endpoints.ts
async function createOp({
  op,
  ...options
}) {
  return (await sendPostRequest({
    uri: `${API_BASE_URL}/operation`,
    body: { ...op },
    ...options
  })).opId;
}
async function getOpsOfWallet({
  walletAddr,
  chainId,
  status,
  ...options
}) {
  const endpoint = status ? `${API_BASE_URL}/operation/wallet/${walletAddr}/chain/${chainId}?status=${status}` : `${API_BASE_URL}/operation/wallet/${walletAddr}/chain/${chainId}`;
  return (await sendGetRequest({ uri: endpoint, ...options })).operations;
}
async function getOps({
  opIds,
  chainId,
  ...options
}) {
  return (await sendPostRequest({
    uri: `${API_BASE_URL}/operation/get-operations`,
    body: {
      opIds,
      chainId
    },
    ...options
  })).operations;
}
async function deleteOp({
  opId,
  chainId,
  ...options
}) {
  await sendDeleteRequest({
    uri: `${API_BASE_URL}/operation/${opId}/chain/${chainId}`,
    ...options
  });
}
async function signOp({
  opId,
  chainId,
  signature,
  signedBy,
  threshold,
  ...options
}) {
  await sendPostRequest({
    uri: `${API_BASE_URL}/operation/sign`,
    body: {
      opId,
      chainId,
      signature,
      signedBy,
      threshold
    },
    ...options
  });
}
async function executeOp({
  input,
  ...options
}) {
  return await sendPostRequest({
    uri: `${API_BASE_URL}/operation/execute`,
    body: input,
    ...options
  });
}
async function estimateOp({
  input,
  ...options
}) {
  return await sendPostRequest({
    uri: `${API_BASE_URL}/operation/estimate`,
    body: input,
    ...options
  });
}
async function scheduleOp({
  input,
  ...options
}) {
  await sendPostRequest({
    uri: `${API_BASE_URL}/operation/schedule`,
    body: input,
    ...options
  });
}
var getFullReceipt = async ({
  opId,
  chainId,
  userOpHash,
  ...options
}) => {
  const retries = 20;
  let result = {
    status: "pending"
  };
  for (let i = 0; i < retries; i++) {
    try {
      result = await sendGetRequest({
        uri: `${API_BASE_URL}/operation/${opId}/chain/${chainId}/receipt?userOpHash=${userOpHash}`,
        ...options
      });
      if (result.status === "included") {
        break;
      }
    } catch (_err) {
    }
    await new Promise((resolve) => setTimeout(resolve, 2500));
  }
  if (!result.receipt) {
    result.receipt = {
      // TODO: this is obviously wrong but it was what we had before
      txId: "Failed to find.",
      gasUsed: "Failed to find.",
      opFeeUSD: "Failed to find.",
      opFee: "Failed to find.",
      userOpHash: "Failed to find."
    };
  }
  return {
    ...result.receipt
  };
};
var getUserOpGasPrice = async ({
  chainId,
  ...options
}) => {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/operation/chain/${chainId}/gas-price`,
    ...options
  });
};

// src/services/fw-operation/types.ts
var OperationStatus = /* @__PURE__ */ ((OperationStatus2) => {
  OperationStatus2["ALL"] = "";
  OperationStatus2["PENDING_APPROVED"] = "PENDING_APPROVED";
  OperationStatus2["APPROVED"] = "APPROVED";
  OperationStatus2["PENDING"] = "PENDING";
  OperationStatus2["OP_SUCCEED"] = "OP_SUCCEED";
  OperationStatus2["OP_REVERTED"] = "OP_REVERTED";
  OperationStatus2["SCHEDULED"] = "SCHEDULED";
  return OperationStatus2;
})(OperationStatus || {});
var AuthType = /* @__PURE__ */ ((AuthType2) => {
  AuthType2[AuthType2["ECDSA"] = 0] = "ECDSA";
  AuthType2[AuthType2["MULTI_SIG"] = 1] = "MULTI_SIG";
  return AuthType2;
})(AuthType || {});
var OperationType = /* @__PURE__ */ ((OperationType2) => {
  OperationType2["SINGLE_OPERATION"] = "SINGLE_OPERATION";
  OperationType2["GROUP_OPERATION"] = "GROUP_OPERATION";
  OperationType2["REJECTION"] = "REJECTION";
  return OperationType2;
})(OperationType || {});

// src/services/fw-paymaster/endpoints.ts
async function addTransaction({
  chainId,
  timestamp,
  txid,
  transaction,
  paymasterType,
  sponsorAddress,
  ...options
}) {
  try {
    return await sendPostRequest({
      uri: `${API_BASE_URL}/dashboard/paymasters/add-transaction`,
      body: {
        chain: chainId,
        sponsorAddress,
        type: paymasterType,
        timestamp,
        transaction,
        txid
      },
      ...options
    });
  } catch (_err) {
  }
}

// src/services/fw-paymaster/types.ts
var PaymasterType = /* @__PURE__ */ ((PaymasterType2) => {
  PaymasterType2["BaseSponsor"] = "base";
  PaymasterType2["GaslessSponsor"] = "gasless";
  PaymasterType2["TokenSponsor"] = "token";
  PaymasterType2["CheckoutSponsor"] = "checkout";
  return PaymasterType2;
})(PaymasterType || {});

// src/services/fw-user/endpoints.ts
import { ResourceNotFoundError as ResourceNotFoundError4 } from "@funkit/utils";
import { InvalidParameterError as InvalidParameterError3 } from "viem";
async function createUser({
  authId,
  addr,
  method,
  userUniqueId,
  ...options
}) {
  await sendPostRequest({
    uri: `${API_BASE_URL}/user`,
    body: {
      authId,
      addr,
      method,
      userUniqueId
    },
    ...options
  });
}
async function getUserUniqueId({
  authId,
  ...options
}) {
  try {
    return (await sendGetRequest({
      uri: `${API_BASE_URL}/user/auth/${authId}/unique-id`,
      ...options
    })).userUniqueId;
  } catch (err) {
    if (err instanceof ResourceNotFoundError4) {
      return "";
    }
    throw err;
  }
}
async function getUserWalletsByAddr({
  addr,
  chainId,
  ...options
}) {
  const endpoint = chainId ? `${API_BASE_URL}/user/addr/${addr}/wallets?chainId=${chainId}` : `${API_BASE_URL}/user/addr/${addr}/wallets`;
  return (await sendGetRequest({ uri: endpoint, ...options })).wallets;
}
async function addUserToWallet({
  authId,
  chainId,
  walletAddr,
  userIds,
  walletUniqueId,
  ...options
}) {
  try {
    await sendPostRequest({
      uri: `${API_BASE_URL}/user/auth/${authId}/chain/${chainId}/wallet`,
      body: { walletAddr, userIds, walletUniqueId },
      ...options
    });
  } catch (err) {
    if (err instanceof InvalidParameterError3) {
      return;
    }
    throw err;
  }
}
async function getUserWalletIdentities({
  authId,
  chainId,
  walletAddr,
  ...options
}) {
  return (await sendGetRequest({
    uri: `${API_BASE_URL}/user/auth/${authId}/chain/${chainId}/wallet/${walletAddr}/identities`,
    ...options
  })).ids ?? [];
}

// src/services/meld/endpoints.ts
async function getMeldSupportedFiat({
  ...options
}) {
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/meld/fiat`,
    ...options,
    retryOptions: { maxAttempts: 2 }
  });
}
async function getMeldQuotes({
  params,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/api/meld/quote`,
    body: params,
    retryOptions: { maxAttempts: 2 },
    ...options
  });
}
async function startMeldSession({
  params,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/api/meld/session`,
    body: {
      sessionData: params,
      sessionType: "BUY"
    },
    retryOptions: { maxAttempts: 2 },
    ...options
  });
}
async function getMeldDefaultFiat({
  params,
  ...options
}) {
  const countries = params.countries?.join(",") ?? "";
  const categories = params.categories?.join(",") ?? "";
  const urlParams = new URLSearchParams({
    ...countries ? { countries } : {},
    ...categories ? { categories } : {}
  });
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/meld/defaultFiat?${urlParams}`,
    ...options,
    retryOptions: { maxAttempts: 2 }
  });
}
async function getMeldFiatLimits({
  params,
  ...options
}) {
  const countries = params.countries.join(",");
  const cryptoCurrencies = params.cryptoCurrencies.join(",");
  const fiatCurrencies = params.fiatCurrencies.join(",");
  const categories = params.categories?.join(",") ?? "";
  const urlParams = new URLSearchParams({
    countries,
    cryptoCurrencies,
    fiatCurrencies,
    ...categories ? { categories } : {}
  });
  return sendGetRequest({
    uri: `${MESH_API_BASE_URL}/api/meld/fiatLimit?${urlParams}`,
    ...options,
    retryOptions: { maxAttempts: 2 }
  });
}

// src/services/meld/types.ts
var MeldServiceProvider = /* @__PURE__ */ ((MeldServiceProvider2) => {
  MeldServiceProvider2["ALCHEMYPAY"] = "ALCHEMYPAY";
  MeldServiceProvider2["BANXA"] = "BANXA";
  MeldServiceProvider2["BILIRA"] = "BILIRA";
  MeldServiceProvider2["BINANCECONNECT"] = "BINANCECONNECT";
  MeldServiceProvider2["BLOCKCHAINDOTCOM"] = "BLOCKCHAINDOTCOM";
  MeldServiceProvider2["BTCDIRECT"] = "BTCDIRECT";
  MeldServiceProvider2["COINBASEPAY"] = "COINBASEPAY";
  MeldServiceProvider2["FONBNK"] = "FONBNK";
  MeldServiceProvider2["GUARDARIAN"] = "GUARDARIAN";
  MeldServiceProvider2["KOYWE"] = "KOYWE";
  MeldServiceProvider2["MERCURYO"] = "MERCURYO";
  MeldServiceProvider2["MESH"] = "MESH";
  MeldServiceProvider2["MESO"] = "MESO";
  MeldServiceProvider2["ONMETA"] = "ONMETA";
  MeldServiceProvider2["ONRAMPMONEY"] = "ONRAMPMONEY";
  MeldServiceProvider2["PAYBIS"] = "PAYBIS";
  MeldServiceProvider2["PAYPAL"] = "PAYPAL";
  MeldServiceProvider2["RAMP"] = "RAMP";
  MeldServiceProvider2["ROBINHOOD"] = "ROBINHOOD";
  MeldServiceProvider2["SARDINE"] = "SARDINE";
  MeldServiceProvider2["SHIFT4"] = "SHIFT4";
  MeldServiceProvider2["SIMPLEX"] = "SIMPLEX";
  MeldServiceProvider2["SKRILLCRYPTO"] = "SKRILLCRYPTO";
  MeldServiceProvider2["STRIPE"] = "STRIPE";
  MeldServiceProvider2["TOPPER"] = "TOPPER";
  MeldServiceProvider2["TRANSAK"] = "TRANSAK";
  MeldServiceProvider2["TRANSFI"] = "TRANSFI";
  MeldServiceProvider2["UNLIMIT"] = "UNLIMIT";
  MeldServiceProvider2["YELLOWCARD"] = "YELLOWCARD";
  return MeldServiceProvider2;
})(MeldServiceProvider || {});
var MELD_PROVIDER_CATEGORIES = [
  "BANK_LINKING",
  "CRYPTO_ONRAMP",
  "CRYPTO_OFFRAMP",
  "CRYPTO_TRANSFER",
  "FIAT_PAYMENTS"
];

// src/services/mesh/endpoints.ts
async function meshGetCryptocurrencyHoldings({
  authToken,
  type,
  ...options
}) {
  return sendPostRequest({
    uri: `${API_BASE_URL}/mesh/holdings/get`,
    body: { authToken, type },
    ...options
  });
}
async function meshGetCryptocurrencyHoldingsProxy({
  brokerType,
  deviceId,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/mesh/holdings/get`,
    body: { brokerType, deviceId },
    ...options
  });
}
async function meshGetTransferIntegrations(options) {
  return sendGetRequest({
    uri: `${API_BASE_URL}/mesh/transfers/managed/integrations`,
    ...options
  });
}
async function meshGetLinkToken({
  userId,
  integrationId,
  restrictMultipleAccounts,
  transferOptions,
  ...options
}) {
  const body = {
    userId,
    ...integrationId && { integrationId },
    ...restrictMultipleAccounts && { restrictMultipleAccounts },
    ...transferOptions && { transferOptions }
  };
  return sendPostRequest({
    uri: `${API_BASE_URL}/mesh/linktoken`,
    body,
    ...options
  });
}
async function meshConfigureTransfer({
  params,
  ...options
}) {
  return sendPostRequest({
    uri: `${API_BASE_URL}/mesh/transfers/managed/configure`,
    body: params,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
}
async function meshConfigureTransferProxy({
  params,
  ...options
}) {
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/mesh/transfers/managed/configure`,
    body: params,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
}
async function meshPreviewTransfer({
  fromAuthToken,
  fromType,
  toAuthToken,
  toType,
  networkId,
  symbol,
  toAddress,
  amount,
  amountInFiat,
  fiatCurrency,
  ...options
}) {
  const body = {
    fromAuthToken,
    fromType,
    ...toAuthToken && { toAuthToken },
    ...toType && { toType },
    ...networkId && { networkId },
    ...symbol && { symbol },
    ...toAddress && { toAddress },
    ...amount && { amount },
    ...amountInFiat && { amountInFiat },
    ...fiatCurrency && { fiatCurrency }
  };
  return sendPostRequest({
    uri: `${API_BASE_URL}/mesh/transfers/managed/preview`,
    body,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
}
async function meshPreviewTransferProxy({
  apiKey,
  logger,
  signal,
  ...props
}) {
  const body = { ...props };
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/mesh/transfers/managed/preview`,
    body,
    apiKey,
    logger,
    retryOptions: { maxAttempts: 1 },
    signal
  });
}
async function meshExecuteTransfer({
  fromAuthToken,
  fromType,
  previewId,
  mfaCode,
  ...options
}) {
  const body = {
    fromAuthToken,
    fromType,
    previewId,
    ...mfaCode && { mfaCode }
  };
  return sendPostRequest({
    uri: `${API_BASE_URL}/mesh/transfers/managed/execute`,
    body,
    ...options
  });
}
async function meshExecuteTransferProxy({
  apiKey,
  logger,
  signal,
  ...props
}) {
  const body = { ...props };
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/mesh/transfers/managed/execute`,
    body,
    apiKey,
    logger,
    signal
  });
}
async function saveTokensToMeshProxy({
  apiKey,
  logger,
  signal,
  ...props
}) {
  const body = { ...props };
  return sendPostRequest({
    uri: `${MESH_API_BASE_URL}/api/tokens`,
    body,
    apiKey,
    logger,
    signal
  });
}
async function removeTokensFromMeshProxy({
  deviceId,
  brokerType,
  ...options
}) {
  return await sendDeleteRequest({
    uri: `${MESH_API_BASE_URL}/api/tokens?deviceId=${deviceId}&brokerType=${brokerType}`,
    ...options
  });
}

// src/services/mesh/types.ts
var MeshExecuteTransferStatus = /* @__PURE__ */ ((MeshExecuteTransferStatus2) => {
  MeshExecuteTransferStatus2["succeeded"] = "succeeded";
  MeshExecuteTransferStatus2["failed"] = "failed";
  MeshExecuteTransferStatus2["mfaRequired"] = "mfaRequired";
  MeshExecuteTransferStatus2["emailConfirmationRequired"] = "emailConfirmationRequired";
  MeshExecuteTransferStatus2["emailConfirmationApprovalRequired"] = "emailConfirmationApprovalRequired";
  MeshExecuteTransferStatus2["deviceConfirmationRequired"] = "deviceConfirmationRequired";
  MeshExecuteTransferStatus2["mfaFailed"] = "mfaFailed";
  MeshExecuteTransferStatus2["addressWhitelistRequired"] = "addressWhitelistRequired";
  MeshExecuteTransferStatus2["secondMfaRequired"] = "secondMfaRequired";
  return MeshExecuteTransferStatus2;
})(MeshExecuteTransferStatus || {});
var MeshExecuteTransferMfaType = /* @__PURE__ */ ((MeshExecuteTransferMfaType2) => {
  MeshExecuteTransferMfaType2["unspecified"] = "unspecified";
  MeshExecuteTransferMfaType2["phone"] = "phone";
  MeshExecuteTransferMfaType2["email"] = "email";
  MeshExecuteTransferMfaType2["totp"] = "totp";
  MeshExecuteTransferMfaType2["face"] = "face";
  MeshExecuteTransferMfaType2["tradingPin"] = "tradingPin";
  MeshExecuteTransferMfaType2["mobile"] = "mobile";
  return MeshExecuteTransferMfaType2;
})(MeshExecuteTransferMfaType || {});
var MeshConfigureTransferStatus = /* @__PURE__ */ ((MeshConfigureTransferStatus2) => {
  MeshConfigureTransferStatus2["failed"] = "failed";
  MeshConfigureTransferStatus2["fromIntegrationNotSupported"] = "fromIntegrationNotSupported";
  MeshConfigureTransferStatus2["kycRequired"] = "kycRequired";
  MeshConfigureTransferStatus2["notAuthorizedFrom"] = "notAuthorizedFrom";
  MeshConfigureTransferStatus2["notAuthorizedTo"] = "notAuthorizedTo";
  MeshConfigureTransferStatus2["succeeded"] = "succeeded";
  MeshConfigureTransferStatus2["toIntegrationNotSupported"] = "toIntegrationNotSupported";
  MeshConfigureTransferStatus2["validationFailed"] = "validationFailed";
  return MeshConfigureTransferStatus2;
})(MeshConfigureTransferStatus || {});

// src/services/moonpay/endpoints.ts
import { ErrorCode as ErrorCode3, InternalFailureError as InternalFailureError2 } from "@funkit/utils";
async function getMoonpayUrlSignature({
  url,
  isSandbox,
  ...options
}) {
  const signature = await sendPostRequest({
    uri: `${API_BASE_URL}/on-ramp/moonpay-signature/`,
    body: { url, isSandbox },
    ...options
  });
  if (!signature || !signature?.url) {
    throw new InternalFailureError2(
      ErrorCode3.UnknownServerError,
      "No onramp url found.",
      "",
      { url },
      "This is an internal error, please contact support.",
      "https://docs.fun.xyz"
    );
  }
  return signature.url;
}
async function getMoonpayBuyQuoteForCreditCard({
  currencyCode,
  baseCurrencyCode,
  quoteCurrencyAmount,
  baseCurrencyAmount,
  extraFeePercentage,
  areFeesIncluded,
  ...options
}) {
  const params = new URLSearchParams({
    currencyCode,
    baseCurrencyCode,
    quoteCurrencyAmount,
    paymentMethod: "credit_debit_card",
    ...baseCurrencyAmount == null ? {} : { baseCurrencyAmount: baseCurrencyAmount.toString() },
    ...extraFeePercentage == null ? {} : { extraFeePercentage: extraFeePercentage.toString() },
    ...areFeesIncluded == null ? {} : { areFeesIncluded: areFeesIncluded.toString() }
  }).toString();
  return sendGetRequest({
    uri: `${API_BASE_URL}/on-ramp/moonpay-buy-quote?${params}`,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
}

// src/services/organization/endpoints.ts
async function getOrganizationIdByApiKey({
  apiKey
}) {
  return await sendGetRequest({
    uri: `${API_BASE_URL}/organization`,
    apiKey
  });
}

// src/services/stripe/endpoints.ts
async function getStripeBuyQuote({
  sourceCurrency,
  destinationAmount,
  destinationCurrency,
  destinationNetwork,
  isSandbox,
  ...options
}) {
  const params = new URLSearchParams({
    isSandbox: isSandbox.toString(),
    sourceCurrency,
    destinationAmount: destinationAmount.toString(),
    // Only allow one currency in this SDK
    destinationCurrencies: destinationCurrency,
    // Only allow one network in this SDK
    destinationNetworks: destinationNetwork
  }).toString();
  const buyQuoteResp = await sendGetRequest({
    uri: `${API_BASE_URL}/on-ramp/stripe-buy-quote?${params}`,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
  return buyQuoteResp;
}
async function createStripeBuySession({
  sourceCurrency,
  destinationAmount,
  destinationCurrency,
  destinationNetwork,
  walletAddress,
  customerIpAddress,
  isSandbox,
  ...options
}) {
  const body = {
    isSandbox: isSandbox.toString(),
    sourceCurrency,
    destinationAmount: destinationAmount.toString(),
    // Only allow one currency in this SDK
    destinationCurrency,
    destinationCurrencies: [destinationCurrency],
    // Only allow one network in this SDK
    destinationNetwork,
    destinationNetworks: [destinationNetwork],
    // Only allow one wallet address in this SDK, and it must correspond to the destination network
    walletAddresses: {
      [destinationNetwork]: walletAddress
    },
    ...customerIpAddress ? { customerIpAddress } : {}
  };
  const newBuySessionResp = await sendPostRequest({
    uri: `${API_BASE_URL}/on-ramp/stripe-checkout`,
    body,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
  return newBuySessionResp;
}
async function getStripeBuySession({
  sessionId,
  ...options
}) {
  const buySessionResp = await sendGetRequest({
    uri: `${API_BASE_URL}/on-ramp/stripe-checkout-session/${sessionId}`,
    retryOptions: { maxAttempts: 1 },
    ...options
  });
  return buySessionResp;
}

// src/services/support/endpoints.ts
async function sendSupportMessage({
  title,
  description,
  userEmail,
  ...options
}) {
  try {
    await sendPostRequest({
      uri: `${API_BASE_URL}/support/send-message`,
      body: { title, description, userEmail },
      retryOptions: { maxAttempts: 1 },
      ...options
    });
    return true;
  } catch (_err) {
    return false;
  }
}
export {
  API_BASE_URL,
  AuthType,
  BANKR_API_KEY,
  BENQI_API_KEY,
  BSX_API_KEY,
  BridgeCustomerStatus,
  BridgeCustomerType,
  BridgeEndorsement,
  BridgeKycStatus,
  BridgeTosStatus,
  BridgeVirtualBankAccountStatus,
  CheckoutRefundState,
  CheckoutState,
  DEFAULT_RETRY_OPTIONS,
  DEGEN_API_KEY,
  DEV_API_KEY,
  DYDX_API_KEY,
  DirectExecutionType,
  ETHEREAL_API_KEY,
  ETHERFI_API_KEY,
  FELIX_API_KEY,
  FROM_PROGRESS_CHECKOUT_STATES,
  FUN_FAUCET_URL,
  IN_PROGRESS_CHECKOUT_STATES,
  KATANA_API_KEY,
  MELD_PROVIDER_CATEGORIES,
  MESH_API_BASE_URL,
  MeldServiceProvider,
  MeshConfigureTransferStatus,
  MeshExecuteTransferMfaType,
  MeshExecuteTransferStatus,
  OSTIUM_API_KEY,
  OperationStatus,
  OperationType,
  POLYMARKET_API_KEY,
  PaymasterType,
  QUICKSWAP_API_KEY,
  RelayExecutionStatus,
  SUSHI_API_KEY,
  TERMINAL_CHECKOUT_STATES,
  TO_PROGRESS_CHECKOUT_STATES,
  addTransaction,
  addUserToWallet,
  checkWalletAccessInitialization,
  createBridgeBankAccount,
  createBridgeCustomer,
  createDirectExecution,
  createFrogAccount,
  createOp,
  createStripeBuySession,
  createUser,
  deactivateCheckout,
  deleteOp,
  errorAbortHandler,
  estimateOp,
  executeOp,
  generateRandomCheckoutSalt,
  getAllWalletNFTs,
  getAllWalletNFTsByChainId,
  getAllWalletTokens,
  getAllWalletTokensByChainId,
  getAllowedAssets,
  getAssetErc20ByChainAndSymbol,
  getAssetFromFaucet,
  getAssetPriceInfo,
  getBridgeBankAccounts,
  getBridgeCustomer,
  getBridgeKycLink,
  getChainFromId,
  getChainFromName,
  getCheckoutByDepositAddress,
  getCheckoutQuote,
  getCheckoutsByFunWalletAddress,
  getCheckoutsByRecipientAddress,
  getCheckoutsByUserId,
  getDirectExecutionByTxHash,
  getDirectExecutionsByUserId,
  getFrogAccount,
  getFullReceipt,
  getGroups,
  getMeldDefaultFiat,
  getMeldFiatLimits,
  getMeldQuotes,
  getMeldSupportedFiat,
  getMoonpayBuyQuoteForCreditCard,
  getMoonpayUrlSignature,
  getNftAddress,
  getNftName,
  getOps,
  getOpsOfWallet,
  getOrganizationIdByApiKey,
  getPaymasterDataForCheckoutSponsoredTransfer,
  getRiskAssessmentForAddress,
  getStripeBuyQuote,
  getStripeBuySession,
  getUserOpGasPrice,
  getUserUniqueId,
  getUserWalletIdentities,
  getUserWalletsByAddr,
  getWalletLidoWithdrawalsByChainId,
  initializeCheckout,
  initializeCheckoutTokenTransferAddress,
  initializeWalletAccess,
  meshConfigureTransfer,
  meshConfigureTransferProxy,
  meshExecuteTransfer,
  meshExecuteTransferProxy,
  meshGetCryptocurrencyHoldings,
  meshGetCryptocurrencyHoldingsProxy,
  meshGetLinkToken,
  meshGetTransferIntegrations,
  meshPreviewTransfer,
  meshPreviewTransferProxy,
  randomBytes,
  removeTokensFromMeshProxy,
  roundToNearestBottomTenth,
  saveTokensToMeshProxy,
  scheduleOp,
  sendDeleteRequest,
  sendGetRequest,
  sendPostRequest,
  sendPutRequest,
  sendRequest,
  sendSupportMessage,
  signOp,
  startMeldSession
};
//# sourceMappingURL=index.js.map
