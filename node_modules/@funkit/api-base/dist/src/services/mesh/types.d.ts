import type { BaseApiRequest } from '../../consts';
export interface MeshError {
    displayMessage?: string | null;
    errorData?: unknown;
    errorType?: string | null;
    message?: string | null;
    status: string;
}
export interface GetCryptocurrencyHoldingsRequest extends BaseApiRequest {
    authToken: string;
    type: string;
}
export interface GetCryptocurrencyHoldingsRequestProxy extends BaseApiRequest {
    deviceId: string;
    brokerType: string;
}
export interface GetTransferIntegrationsRequest extends BaseApiRequest {
}
export interface IntegrationNetworkInfo {
    chainId: string;
    id: string;
    logoUrl: string;
    name: string;
    nativeSymbol: string;
    supportedTokens: string[];
}
export interface TransferIntegration {
    networks: IntegrationNetworkInfo[];
    supportsIncomingTransfers: boolean;
    supportsOutgoingTransfers: boolean;
    type: string;
}
export interface GetTransferIntegrationsResponse {
    integrations: TransferIntegration[];
}
export interface GetLinkTokenRequest extends BaseApiRequest {
    userId: string;
    integrationId?: string | null;
    restrictMultipleAccounts?: boolean;
    transferOptions?: Record<string, unknown> | null;
}
export interface GetLinkTokenResponse {
    linkToken: string;
}
export interface PreviewTransferRequest extends BaseApiRequest {
    fromAuthToken: string;
    fromType: string;
    toAuthToken?: string | null;
    toType?: string | null;
    networkId?: string;
    symbol?: string | null;
    toAddress?: string | null;
    amount?: string | null;
    amountInFiat?: string | null;
    fiatCurrency?: string | null;
}
export interface PreviewTransferRequestProxy extends Omit<PreviewTransferRequest, 'fromAuthToken' | 'fromType'> {
    deviceId: string;
    brokerType: string;
}
export interface MeshExecuteTransferRequest extends BaseApiRequest {
    fromAuthToken: string;
    fromType: string;
    previewId: string;
    mfaCode?: string | null;
}
export interface MeshExecuteTransferRequestProxy extends Omit<MeshExecuteTransferRequest, 'fromAuthToken' | 'fromType'> {
    deviceId: string;
    brokerType: string;
}
export declare enum MeshExecuteTransferStatus {
    succeeded = "succeeded",
    failed = "failed",
    mfaRequired = "mfaRequired",
    emailConfirmationRequired = "emailConfirmationRequired",
    emailConfirmationApprovalRequired = "emailConfirmationApprovalRequired",
    deviceConfirmationRequired = "deviceConfirmationRequired",
    mfaFailed = "mfaFailed",
    addressWhitelistRequired = "addressWhitelistRequired",
    secondMfaRequired = "secondMfaRequired"
}
export declare enum MeshExecuteTransferMfaType {
    unspecified = "unspecified",
    phone = "phone",
    email = "email",
    totp = "totp",
    face = "face",
    tradingPin = "tradingPin",
    mobile = "mobile"
}
export interface MeshExecuteTransferResponse {
    status: MeshExecuteTransferStatus;
    mfaType?: MeshExecuteTransferMfaType;
    verificationSteps?: MeshExecuteTransferMfaType[];
    errorMessage: string | null;
    executeTransferResult: object | null;
}
export interface MeshCryptoCurrencyPosition {
    symbol: string;
    amount: number;
}
export interface GetCryptocurrencyHoldingsResponse {
    cryptocurrencyPositions: MeshCryptoCurrencyPosition[];
}
export interface MeshProxyUnauthorizedResponse {
    error: string;
}
export interface PreviewTransferResponse {
    /** The status of the operation. */
    status: 'succeeded' | 'failed' | 'requiresFunding';
    /** Error message, if the operation did not complete successfully. */
    errorMessage: string | null;
    /** Result of the preview. */
    previewResult: PreviewTransferResult | null;
    transferBalanceFundingAvailability: TransferBalanceFundingAvailability | null;
}
export interface PreviewTransferResult {
    previewId: string;
    previewExpiresIn: number;
    fromAddress: string | null;
    toAddress: string | null;
    addressTag: string | null;
    symbol: string | null;
    amount: number;
    amountInFiat: number;
    totalEstimatedAmount: number;
    totalEstimatedAmountInFiat: number;
    networkId: string;
    networkName: string | null;
    contractAddress: string | null;
    institutionTransferFee: TransferFee | null;
    estimatedNetworkGasFee: TransferFee | null;
    decimalPlaces: number | null;
    unitPrice: number;
    clientTransactionId: string | null;
    clientFee: number | null;
    customClientFee: TransferFee | null;
    processingFeeRetainMethod: ProcessingFeeRetainMethod | null;
    transferType: TransferTypeEnum | null;
    isCustomClientFeeProvided: boolean;
    amountWithCustomClientFee: number;
    isFeeIncluded: boolean;
    amountToReceive: number;
    amountToReceiveInFiat: number;
    transferAmountToRequest: number;
}
export interface TransferFee {
    fee: number;
    feeCurrency: string | null;
    feeInFiat: number;
}
export interface ProcessingFeeRetainMethod {
    type: 'default' | 'smartDeposit';
    processingFeeAddress: string | null;
}
export type TransferTypeEnum = 'deposit' | 'payment' | 'onramp';
export interface TransferBalanceFundingAvailability {
    status: 'disabled' | 'available' | 'requiresAmountLowering' | 'notApplicable' | 'unavailable';
    transferTotalAmount: number;
    unitPrice: number;
    gasFeeBuffer: TransferFee | null;
    symbol: string | null;
    transferTotalAmountInFiat: number;
}
export interface MeshConfigureTransferToAddressParams {
    /**
     * The address to send the asset to.
     */
    address: string;
    /**
     * Secondary address identifier for coins like XRP, XMR, etc.
     */
    addressTag?: string | null;
    /**
     * The ID of the network in Front system.
     */
    networkId: string;
    /**
     * The symbol of the digital asset.
     */
    symbol: string;
}
export interface MeshConfigureTransferParams {
    /**
     * The authentication token to send assets from.
     */
    fromAuthToken: string;
    /**
     * The type of the integration to send assets from.
     */
    fromType: string;
    /**
     * The authentication token of the target integration. Can be used alternatively to the list of requested address ({@link toAddresses}).
     *
     * If used, {@link toType} should also be provided.
     */
    toAuthToken?: string | null;
    /**
     * The type of the target integration to send assets to. Used along with the {@link toAuthToken} alternatively to {@link toAddresses}.
     */
    toType?: string | null;
    /**
     * A list of available addresses provided by the API client. The list can contain all supported addresses by the client.
     *
     * Front API validates the addresses and returns the list of supported tokens and networks as the result of the operation.
     */
    toAddresses?: MeshConfigureTransferToAddressParams[] | null;
    /**
     * If provided, Front API returns only networks that support transferring of this symbol.
     */
    symbol?: string | null;
    /**
     * If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer.
     */
    amount?: number | null;
    /**
     * If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer. Can be used alternatively to {@link amount}.
     */
    amountInFiat?: number | null;
    /**
     * Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `"USD"`.
     */
    fiatCurrency?: string | null;
    /**
     * If provided, Front API configures the response to include the requested network only.
     */
    networkId?: string | null;
    /**
     * Specifies if all the fees are included in the amount to transfer.
     */
    isInclusiveFeeEnabled?: boolean;
}
export interface MeshConfigureTransferParamsProxy extends Omit<MeshConfigureTransferParams, 'fromAuthToken' | 'fromType'> {
    deviceId: string;
    brokerType: string;
}
export interface MeshConfigureTransferResponse {
    amountInFiat?: number | null;
    fiatCurrency?: string | null;
    holdings?: {
        availableBalance: number;
        availableBalanceInFiat: number;
        eligibleForTransfer: boolean;
        eligibleForTransferWithFunding: boolean;
        ineligibilityReason?: 'amountNotSufficient' | 'eligibleWithFunding' | 'noEligibleNetworks' | 'noPrice' | 'notSupportedForTransferBySource' | 'notSupportedForTransferByTarget' | 'symbolDoesNotMatch';
        logoUrl?: string | null;
        networks: {
            caipNetworkId?: string | null;
            eligibleForTransfer: boolean;
            eligibleForTransferWithFunding: boolean;
            estimatedNetworkGasFee?: {
                fee: number;
                feeCurrency?: string | null;
                feeInFiat: number;
            };
            id: string;
            ineligibilityReason?: 'amountNotSufficient' | 'balanceBelowMinimum' | 'balanceBelowRequestedAmount' | 'eligibleWithFunding' | 'gasFeeAssetBalanceNotEnough' | 'noPrice' | 'nyCoinbaseUserRestrictions' | 'refusedByInstitution' | 'requestedAmountAboveClientMaximum' | 'requestedAmountBelowFees' | 'requestedAmountBelowClientMinimum' | 'requestedAmountBelowMinimum';
            institutionTransferFee?: {
                fee: number;
                feeCurrency?: string | null;
                feeInFiat: number;
            };
            logoUrl?: string | null;
            maximumAmount?: number | null;
            maximumAmountInFiat?: number | null;
            minimumAmount?: number | null;
            minimumAmountInFiat?: number | null;
            minimumRequiredForTransferAmount?: number | null;
            name?: string | null;
            totalEstimatedTransferFeeInFiat?: number | null;
            toAddress?: string | null;
            transferAmount?: number | null;
        }[];
        symbol?: string | null;
    }[];
    maximumTransferAmountInFiat?: number | null;
    minimumTransferAmountInFiat?: number | null;
    status: MeshConfigureTransferStatus;
    supportedFiatCurrencies?: string[] | null;
    transferBalanceFundingAvailability?: {
        status: 'available' | 'disabled' | 'notApplicable' | 'requiresAmountLowering' | 'unavailable';
    };
}
export declare enum MeshConfigureTransferStatus {
    failed = "failed",
    fromIntegrationNotSupported = "fromIntegrationNotSupported",
    kycRequired = "kycRequired",
    notAuthorizedFrom = "notAuthorizedFrom",
    notAuthorizedTo = "notAuthorizedTo",
    succeeded = "succeeded",
    toIntegrationNotSupported = "toIntegrationNotSupported",
    validationFailed = "validationFailed"
}
